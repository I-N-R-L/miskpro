const fs = require("fs");
const {
    default: WASocket,
    useMultiFileAuthState,
    makeInMemoryStore,
    Browsers,
} = require("@whiskeysockets/baileys");
const pino = require("pino");
const axios = require('axios');
const express = require("express");
const app = express();
const port = process.env.PORT || 7000;
const path = require("path");
const Welcome = require("./lib/greetings");
const os = require('os')
const ffmpeg = require('fluent-ffmpeg');
optionalDependencies = {
    "@ffmpeg-installer/darwin-arm64": "4.1.5",
    "@ffmpeg-installer/darwin-x64": "4.1.0",
    "@ffmpeg-installer/linux-arm": "4.1.3",
    "@ffmpeg-installer/linux-arm64": "4.1.4",
    "@ffmpeg-installer/linux-ia32": "4.1.0",
    "@ffmpeg-installer/linux-x64": "4.1.0",
    "@ffmpeg-installer/win32-ia32": "4.1.0",
    "@ffmpeg-installer/win32-x64": "4.1.0"
}
let platform = os.platform() + '-' + os.arch();
let packageName = '@ffmpeg-installer/' + platform;
if (optionalDependencies[packageName]) {
    const ffmpegPath = require('@ffmpeg-installer/ffmpeg').path;
    ffmpeg.setFfmpegPath(ffmpegPath);
}
const {
    commands,
    sleep,
    serialize,
    WAConnection,
    connect,
    getListOfPlugin,
    getAntiLink,
    getPdm,
    CreateDb,
    decrypt,
    UpdateVariable,
    getVar,
    getTog,
    isFiltered,
    addFilter,
    userQuickMsgd,
    addQuickMsgd,
    getAntiWords,
    SpamAdd,
    UserSparmed,
    giveWarn,
    isWarned,
    getCmdV2,
    sendFilterMessage,
    setWarn,
    ResetWarn,
    isAdmin,
    isBotAdmin,
    badWordDetect,
    getGreet,
    getAntiFake,
    getMute,
    getUnMute,
    dlt_plugin
} = require("./lib/");
const {
    STATUS_VIEW,
    CALL_BLOCK,
    PM_BLOCK,
    BOT_PRESENCE,
    REACT,
    ALLWAYS_ONLINE,
    READ_CHAT,
    DATABASE,
    ANTI_SPAM,
    BASE_URL,
    WARNCOUND,
    SPAM_BLOCK,
    REJECT_CALL,
    BADWORD_BLOCK,
    READ_COMMANDS,
    BAN_CHAT,
    WELCOME_MSG,
    EXIT_MSG,
    REACT_CMD,
    REACT_EMOJI,
    SAVE_STATUS,
    SESSION_ID,
    SUDO,
    ALIVE_DATA,
    WORKTYPE,
    PREFIX,
    BLOCK_CHAT,
    AUTO_BIO
} = require('./config');
let session = decrypt(SESSION_ID.replace("inrl~", "")),
    ext_plugins = 0;
async function toCOnnect() {
    await connect(session);
}
toCOnnect()
String.prototype.format = function() {
    let i = 0,
        args = arguments;
    return this.replace(/{}/g, function() {
        return typeof args[i] != 'undefined' ? args[i++] : '';
    });
};
Array.prototype.remove = function() {
    let what, a = arguments,
        L = a.length,
        ax;
    while (L && this.length) {
        what = a[--L];
        while ((ax = this.indexOf(what)) !== -1) {
            this.splice(ax, 1);
        }
    }
    return this;
};

function insertSudo(SUDO) {
    let CreaterAr = [];
    if (SUDO == 'null' || SUDO == 'false' || !SUDO) return ['']
    if (SUDO.includes(',')) {
        let sudok = SUDO.replaceAll(' ', '');
        a = sudok.split(',');
        a.map((t) => {
            t = t + '@s.whatsapp.net';
            CreaterAr.push(t);
        })
    } else {
        IsSudo = SUDO.trim() + '@s.whatsapp.net';
        CreaterAr.push(IsSudo);
    }
    return CreaterAr;
};

function removeFile(FilePath) {
    const tmpFiless = fs.readdirSync('./' + FilePath)
    tmpFiless.map((tmpFiles) => {
        if (path.extname(tmpFiles).toLowerCase() == ".mp4") {
            fs.unlinkSync('./' + FilePath + '/' + tmpFiles)
        }
        if (path.extname(tmpFiles).toLowerCase() == ".gif") {
            fs.unlinkSync('./' + FilePath + '/' + tmpFiles)
        }
        if (path.extname(tmpFiles).toLowerCase() == ".webp") {
            fs.unlinkSync('./' + FilePath + '/' + tmpFiles)
        }
        if (path.extname(tmpFiles).toLowerCase() == ".jpg") {
            fs.unlinkSync('./' + FilePath + '/' + tmpFiles)
        }
        if (path.extname(tmpFiles).toLowerCase() == ".jpeg") {
            fs.unlinkSync('./' + FilePath + '/' + tmpFiles)
        }
        if (path.extname(tmpFiles).toLowerCase() == ".mp3") {
            fs.unlinkSync('./' + FilePath + '/' + tmpFiles)
        }
        if (path.extname(tmpFiles).toLowerCase() == ".wav") {
            fs.unlinkSync('./' + FilePath + '/' + tmpFiles)
        }
        if (path.extname(tmpFiles).toLowerCase() == ".bin") {
            fs.unlinkSync('./' + FilePath + '/' + tmpFiles)
        }
    });
    return true
};
console.log('await few secounds to start Bot');
const store = makeInMemoryStore({
    logger: pino().child({
        level: "silent",
        stream: "store"
    }),
});
const WhatsBotConnect = async () => {
    try {
        console.log("Syncing Database");
        await DATABASE.sync();
        const {
            state,
            saveCreds
        } = await useMultiFileAuthState(__dirname + '/auth_info_baileys');
        const logger = pino({
            level: "silent"
        });
        let conn = await WASocket({
            logger,
            browser: Browsers.macOS("Desktop"),
            auth: state,
            generateHighQualityLinkPreview: true
        });
        conn.ev.on("creds.update", saveCreds);
        store.bind(conn.ev);
        setInterval(() => {
            store.writeToFile("./lib/store.json");
        }, 30 * 1000);
        conn = new WAConnection(conn);
        conn.ev.on("connection.update", async (update) => {
            const {
                connection
            } = update;
            if (connection == "connecting") console.log("💖 Connecting to WhatsApp...🥳");
            else if (connection == "open") {
                console.log('storing paird keys')
                await CreateDb(conn.user.id.split(':')[0],{
                    ALIVE_DATA,
                    WELCOME_MSG,
                    EXIT_MSG
                })
                console.log("installing plugins🔘");
                let list = await getListOfPlugin();
                list.map(async (plugin) => {
                    try {
                        const {
                            data
                        } = await axios(plugin.dataValues.url);
                        fs.writeFileSync(
                            "./plugins/" + plugin.dataValues.name + ".js",
                            data
                        );
                    } catch (e) {
                        ext_plugins = --ext_plugins
                        await dlt_plugin(plugin.dataValues.name)
                        console.log('there is an error in plugin\nplugin nam :' + plugin.dataValues.name)
                    }
                });
                console.log('external plugins installed successfully')
                console.log('extracting your country code\n please Waite');
                const zone = await getVar('TIME_ZONE',conn.user.id.split(':')[0])
                if (!zone) {
                    const contry = await axios(BASE_URL + `api/phone?number=${conn.user.id.split(':')[0]}`);
                    let country_code = contry.data.result;
                    console.log(`are you  from ${country_code}\nchecking your TimeZone`);
                    timezons = await axios(BASE_URL + `api/zone?code=${country_code}`);
                    timezons = timezons.data.result;
                    console.log(`by default! your timezone is ${timezons}`);
                    await UpdateVariable("TIME_ZONE", timezons, conn.user.id.split(':')[0]);
                }
                fs.readdirSync("./plugins").forEach((plugin) => {
                    if (path.extname(plugin).toLowerCase() == ".js") {
                        require("./plugins/" + plugin);
                    }
                });
                console.log("plugin installed successfully☑️");
                console.log("💖 Login successful! \n bot working now💗");
                conn.sendMessage(conn.user.id, {
                    text: '```' + `bot working now!!\n\n\nversion : ${require("./package.json").version}\nplugins : ${commands.length.toString()}\nexternel : ${ext_plugins}\nmode : ${WORKTYPE}\nprefix : ${PREFIX}\n${String.fromCharCode(8206).repeat(4001)}\nuse command "settings" to update vars like mode` + '```'
                })
                const {TIME_ZONE} = await getVar('TIME_ZONE',conn.user.id.split(':')[0]);
                let createrS = await insertSudo(SUDO);
                let BLOCKCHAT = BLOCK_CHAT.replaceAll(' ', '');
                conn.ev.on("group-participants.update", async (m) => {
                    if (BLOCKCHAT) {
                        if (BLOCKCHAT.includes(m.id)) return;
                    }
                    const greet = await getGreet(m.id)
                    if(greet){
                        greet.TIME_ZONE = TIME_ZONE;
                    await Welcome(m,conn, greet);
                    }
                    const {
                        data,
                        status
                    } = await getAntiFake(m.id);
                    if (status) {
                        const notAllowed = data.split(',') || [data];
                        notAllowed.map(async (num) => {
                            if (m.participants[0].startsWith(num)) {
                                await conn.groupParticipantsUpdate(m.id, m.participants, "remove");
                            }
                        })
                    }
                    const pdm = await getPdm(m.id);
                    if (pdm) {
                        if (m.action == 'promote') {
                            await conn.sendMessage(m.id, {
                                text: '_' + `@${m.participants[0].split("@")[0]} promoted` + '_',
                                mentions: m.participants
                            })
                        } else if (m.action == 'demote') {
                            await conn.sendMessage(m.id, {
                                text: '_' + `@${m.participants[0].split("@")[0]} demoted` + '_',
                                mentions: m.participants
                            })
                        }
                    }
                });
                conn.ev.on("messages.upsert", async (chatUpdate) => {
                    if (chatUpdate.messages[0]?.message?.reactionMessage) return;
                    let em_ed = false;
                    let m = new serialize(conn, chatUpdate.messages[0], createrS, store);
                    let is_res_block = m.client.body.toLowerCase();
                    if (BLOCKCHAT.includes(m.jid.replace(/[^0-9]/g, ''))) {
                        if (!is_res_block.includes('antibot') && !is_res_block.includes('restart') && !is_res_block.includes('ban')) em_ed = true;
                    }
                    if (chatUpdate.messages[0].key.remoteJid == "status@broadcast") {
                        if (STATUS_VIEW == 'true') {
                            await conn.readMessages([chatUpdate.messages[0].key])
                        }
                        if (m.client.isMedia && SAVE_STATUS == 'true') {
                            const tdate = new Date().toLocaleDateString("EN", {
                                weekday: "long",
                                year: "numeric",
                                month: "long",
                                day: "numeric",
                            });
                            const ttime = new Date().toLocaleString("LK", {
                                timeZone: TIME_ZONE
                            }).split(" ")[1];
                            let caption = `sender : ${m.client.number}\n`;
                            caption += m.client.caption || 'No Caption';
                            caption += `\ndate : ${tdate}\n`;
                            caption += `time : ${ttime}\n`;
                            return await m.conn.sendMessage(conn.user.id, {
                                [m.type.replace('Message', '')]: await m.conn.downloadMediaMessage(m.message[m.type]),
                                caption
                            });
                        }
                    }
                    if (m.from == "120363040291283569@g.us" && !m?.fromMe) return;
                    if (BAN_CHAT && BAN_CHAT.includes(m.sender.replace(/[^0-9]/g, ''))) return;
                    if (!m.fromMe && !m.client.body.includes('filter') && !m.client.body.includes('stop') && m.isGroup) {
                        const chat = await sendFilterMessage(m.from, m.client.body.toLowerCase(), m);
                        if (chat) {
                            m.isBot = false;
                            m.isInrl = true;
                            m.client.body = chat;
                        }
                    }
                    if (!m.isGroup && !m.client.isCreator) {
                        if (SPAM_BLOCK == "true" && m.client.body.length > 500) {
                            if (userQuickMsgd(m.from)) {
                                await conn.updateBlockStatus(m.from, "block")
                                const tdate = new Date().toLocaleDateString("EN", {
                                    weekday: "long",
                                    year: "numeric",
                                    month: "long",
                                    day: "numeric",
                                });
                                const ttime = new Date().toLocaleString("LK", {
                                    timeZone: TIME_ZONE
                                }).split(" ")[1];
                                let msg = `❒═════❬ *_SPAM BLOCK_* ❭═════❒\n\n*number* : ${m.sender.replace(/[^0-9]/g,'')}\n*time* : ${ttime}\n*date* : ${tdate}\n*reason* : ${m.type}`;
                                return await conn.sendMessage(conn.user.id, {
                                    text: msg
                                }, {
                                    quoted: m
                                });
                            }
                            if (m.client.body.length > 500) {
                                addQuickMsgd(m.from);
                            }
                        }
                        conn.ws.on('CB:call', async (json) => {
                            if (json.content[0].tag == 'offer') {
                                const tdate = new Date().toLocaleDateString("EN", {
                                    weekday: "long",
                                    year: "numeric",
                                    month: "long",
                                    day: "numeric",
                                });
                                const ttime = new Date().toLocaleString("LK", {
                                    timeZone: TIME_ZONE
                                }).split(" ")[1];
                                callfrom = json.content[0].attrs['call-creator'];
                                const call_id = json.content[0].attrs['call-id'];
                                if (CALL_BLOCK == "true") {
                                    await conn.rejectCall(call_id, callfrom).catch(e => m.send(e));
                                    await sleep(10000);
                                    await conn.updateBlockStatus(callfrom, "block");
                                    let msg = `❒═════❬ *_CALL BLOCK_* ❭═════❒\n\n*number* : ${callfrom.replace(/[^0-9]/g,'')}\n*time* : ${ttime}\n*date* : ${tdate}`;
                                    return await conn.sendMessage(conn.user.id, {
                                        text: msg
                                    });
                                }
                                if (REJECT_CALL == "true") {
                                    await conn.rejectCall(call_id, callfrom).catch(e => m.send(e));
                                    let msg = `❒═════❬ *_REJECTED CALL_* ❭═════❒\n\n*number* : ${callfrom.replace(/[^0-9]/g,'')}\n*time* : ${ttime}\n*date* : ${tdate}`;
                                    await sleep(5000);
                                    return await conn.sendMessage(conn.user.id, {
                                        text: msg
                                    });
                                }
                            }
                        });
                        if (PM_BLOCK == "true") {
                            await conn.updateBlockStatus(m.from, "block")
                            const tdate = new Date().toLocaleDateString("EN", {
                                weekday: "long",
                                year: "numeric",
                                month: "long",
                                day: "numeric",
                            });
                            const ttime = new Date().toLocaleString("LK", {
                                timeZone: TIME_ZONE
                            }).split(" ")[1];
                            let msg = `❒═════❬ *_PM BLOCK_* ❭═════❒\n\n*number* : ${m.sender.replace(/[^0-9]/g,'')}\n*time* : ${ttime}\n*date* : ${tdate}\n*reason* : ${m.type}`;
                            return await conn.sendMessage(conn.user.id, {
                                text: msg
                            }, {
                                quoted: m
                            });
                        }
                        if (BADWORD_BLOCK == "true" && badWordDetect(m.client.body.toLowerCase())) {
                            await conn.updateBlockStatus(m.from, "block")
                            const tdate = new Date().toLocaleDateString("EN", {
                                weekday: "long",
                                year: "numeric",
                                month: "long",
                                day: "numeric",
                            });
                            const ttime = new Date().toLocaleString("LK", {
                                timeZone: TIME_ZONE
                            }).split(" ")[1];
                            let msg = `❒════❬ *_BADWORD BLOCK_* ❭════❒\n\n*number* : ${m.sender.replace(/[^0-9]/g,'')}\n*time* : ${ttime}\n*date* : ${tdate}\n*reason* : ${m.client.body}`;
                            return await conn.sendMessage(conn.user.id, {
                                text: msg
                            }, {
                                quoted: m
                            });
                        }
                    }
                    let togcmds = await getTog();
                    let handler = PREFIX == 'false' ? false : PREFIX.trim()
                    let noncmd = handler == false ? false : true;
                    if (handler != false && (handler.startsWith('[') && handler.endsWith(']'))) {
                        let handl = handler.replace('[', '').replace(']', '');
                        handl.split('').map(h => {
                            if (m.client.body.startsWith(h)) {
                                m.client.body = m.client.body.replace(h, '').trim()
                                noncmd = false;
                                handler = h;
                            } else if (h == " ") {
                                m.client.body = m.client.body.trim()
                                noncmd = false;
                                handler = h;
                            }
                        })
                    } else if (handler != false && m.client.body.startsWith(handler)) {
                        m.client.body = m.client.body.replace(handler, '').trim()
                        noncmd = false
                    }
                    if (m.isInrl) noncmd = false;
                    let MOD = WORKTYPE.toLowerCase() == 'public' ? 'public' : 'private';
                    if (m.msg && m.msg.fileSha256 && m.type === "stickerMessage") {
                        const cmds = await getCmdV2(m.msg.fileSha256.join(""));
                        if (cmds) {
                            m.client.body = cmds.dataValues.cmd;
                            noncmd = false;
                        }
                    }
                    let resWithText = false,
                        resWithCmd = false;
                    if (m.quoted && m.quoted.fromMe && m.quoted.text && m.client.body && !isNaN(m.client.body)) {
                        let textformat = m.quoted.text.split('\n');
                        if (textformat[0]) {
                            textformat.map((s) => {
                                if (s.includes('```') && s.split('```').length == 3 && s.match(".")) {
                                    const num = s.split('.')[0].replace(/[^0-9]/g, '')
                                    if (num && (num == m.client.body)) {
                                        resWithCmd += s.split('```')[1];
                                    }
                                }
                            });
                            if (m.quoted.text.includes('*_') && m.quoted.text.includes('_*')) {
                                resWithText += " " + m.quoted.text.split('*_')[1].split('_*')[0]
                            }
                        }
                    }
                    if ((resWithCmd != false) && (resWithText != false)) {
                        m.client.body = resWithCmd.replace(false, "") + resWithText.replace(false, "");
                        noncmd = false;
                        m.isBot = false;
                        resWithCmd = false;
                        resWithText = false;
                    }
                    if (ALLWAYS_ONLINE == "true") {
                        await conn.sendPresenceUpdate("available", m.from);
                    } else {
                        await conn.sendPresenceUpdate("unavailable", m.from);
                    }
                    let isReact = false;
                    commands.map(async (command) => {
                        if (em_ed == "active") em_ed = false;
                        if (MOD == 'private' && !m.client.isCreator) {
                            if (command.fromMe != 'public' && !m.isInrl) {
                                em_ed = "active";
                            }
                        }
                        togcmds.map((l) => {
                            if (m.client.body.toLowerCase().startsWith(l)) {
                                em_ed = "active"
                            }
                        });
                        if (!command.pattern && !command.on) em_ed = "active";
                        if (m.isBot && !command.allowBot) em_ed = "active";
                        if (!em_ed) {
                            if (command.pattern) {
                                EventCmd = command.pattern.replace(/[^a-zA-Z0-9-+]/g, '')
                                if (m.client.body.toLowerCase().startsWith(EventCmd) && (command.DismissPrefix || !noncmd)) {
                                    m.client.command = handler + EventCmd
                                    m.client.text = m.client.body.slice(EventCmd.length).trim();
                                    if (m.client.text == 'help' || m.client.text == 'use' || m.client.text == 'usage' || m.client.text == 'work') {
                                        if (command.usage == "undefined" || command.usage == "null" || command.usage == "false" || !command.usage) {
                                            return await m.send('sorry dear! command usage not found!!')
                                        } else return await m.send(command.usage)
                                    }
                                    if (command.fromMe == true && !m.client.isCreator) {
                                        return;
                                    }
                                    if (command.onlyGroup == true && !m.isGroup) {
                                        return await m.send('_this plugin only work in group_')
                                    }
                                    if (command.onlyPm == true && m.isGroup) {
                                        return await m.send('_this plugin only work in personel chat_')
                                    }
                                    if (command.media == "text" && !m.client.displayText) {
                                        return await m.send('this plugin only response when data as text');
                                    } else if (command.media == "sticker" && !/webp/.test(m.client.mime)) {
                                        return await m.send('this plugin only response when data as sticker');
                                    } else if (command.media == "image" && !/image/.test(m.client.mime)) {
                                        return await m.send('this plugin only response when data as image');
                                    } else if (command.media == "video" && !/video/.test(m.client.mime)) {
                                        return await m.send('this plugin only response when data as video');
                                    } else if (command.media == "audio" && !/audio/.test(m.client.mime)) {
                                        return await m.send('this plugin only response when data as audio');
                                    }
                                    if (SPAM_BLOCK == "true" && !m.isGroup && !m.client.isCreator) {
                                        if (!isWarned(m.jid)) {
                                            giveWarn(m.jid);
                                            await m.send('*Listen! The owner has permission to block spammers, so you will be blocked if spamming is detected. You must give a 5 second pause after each request to avoid blocking*');
                                        }
                                        if (UserSparmed(m.jid)) {
                                            const tdate = new Date().toLocaleDateString("EN", {
                                                weekday: "long",
                                                year: "numeric",
                                                month: "long",
                                                day: "numeric",
                                            });
                                            const ttime = new Date().toLocaleString("LK", {
                                                timeZone: TIME_ZONE
                                            }).split(" ")[1];
                                            await conn.updateBlockStatus(m.jid, "block");
                                            let msg = `❒═════❬ *_SPAM BLOCK_* ❭═════❒\n\n*number* : ${m.sender.replace(/[^0-9]/g,'')}\n*time* : ${ttime}\n*date* : ${tdate}\n*reason* : ${m.type}`;
                                            return await conn.sendMessage(conn.user.id, {
                                                text: msg
                                            }, {
                                                quoted: m
                                            });
                                        }
                                        SpamAdd(m.jid);
                                    }
                                    if (ANTI_SPAM == "true" && isFiltered(m.from) && !m.client.isCreator) return;
                                    if (ANTI_SPAM == "true") addFilter(m.from);
                                    if (READ_COMMANDS == 'true') {
                                        await conn.readMessages([chatUpdate.messages[0].key])
                                    }
                                    await command.function(m, m.client.text, m.client.command, store).catch((e) => console.log(e));
                                    await conn.sendPresenceUpdate(BOT_PRESENCE, m.from);
                                    if (REACT == 'true') {
                                        isReact = true;
                                        await sleep(100)
                                        await conn.sendMessage(m.from, {
                                            react: {
                                                text: command.react || "🙈",
                                                key: m.key
                                            }
                                        });
                                    } else if (REACT_CMD == "true") {
                                        isReact = true;
                                        await sleep(100)
                                        await conn.sendMessage(m.from, {
                                            react: {
                                                text: command.react || "👋🏿",
                                                key: m.key
                                            }
                                        });
                                    }
                                }
                            }
                            if (command.on === "all" && m) {
                                if (command.fromMe == true && !m.client.isCreator) return;
                                if (command.onlyGroup == true && !m.isGroup) return;
                                if (command.onlyPm == true && m.isGroup) return;
                                command.function(m, m.client.text, m.client.command, chatUpdate, store);
                            } else if (command.on === "text" && m.client.displayText) {
                                if (command.fromMe == true && !m.client.isCreator) return;
                                if (command.onlyGroup == true && !m.isGroup) return;
                                if (command.onlyPm == true && m.isGroup) return;
                                command.function(m, m.client.text, m.client.command, chatUpdate);
                            } else if (command.on === "sticker" && m.type === "stickerMessage") {
                                if (command.fromMe == true && !m.client.isCreator) return;
                                if (command.onlyGroup == true && !m.isGroup) return;
                                if (command.onlyPm == true && m.isGroup) return;
                                command.function(m, m.client.text, m.client.command, chatUpdate);
                            } else if (command.on === "image" && m.type === "imageMessage") {
                                if (command.fromMe == true && !m.client.isCreator) return;
                                if (command.onlyGroup == true && !m.isGroup) return;
                                if (command.onlyPm == true && m.isGroup) return;
                                command.function(m, m.client.text, m.client.command, chatUpdate);
                            } else if (command.on === "video" && m.type === "videoMessage") {
                                if (command.fromMe == true && !m.client.isCreator) return;
                                if (command.onlyGroup == true && !m.isGroup) return;
                                if (command.onlyPm == true && m.isGroup) return;
                                command.function(m, m.client.text, m.client.command, chatUpdate);
                            } else if (command.on === "audio" && m.type === "audioMessage") {
                                if (command.fromMe == true && !m.client.isCreator) return;
                                if (command.onlyGroup == true && !m.isGroup) return;
                                if (command.onlyPm == true && m.isGroup) return;
                                command.function(m, m.client.text, m.client.command, chatUpdate);
                            }
                        }
                    });
                    // some externel function
                    try {
                        if (READ_CHAT == "true") {
                            conn.readMessages([m.key])
                        }
                        if (m.message) {
                            console.log("[ MESSAGE ]"),
                                console.log(new Date()),
                                console.log(m.client.displayText || m.type) + "\n" + console.log("=> From"),
                                console.log(m.client.pushName),
                                console.log(m.sender) + "\n" + console.log("=> In"),
                                console.log(m.isGroup ? m.client.pushName : "Private Chat", m.from)
                        }
                    } catch (err) {
                        console.log(err);
                    }
                    let isRunned = false;
                    if (isRunned == false) {
                        if (AUTO_BIO && AUTO_BIO != 'false') {
                            setInterval(async () => {
                                pstime = new Date().toLocaleDateString("EN", {
                                    weekday: "long",
                                    year: "numeric",
                                    month: "long",
                                    day: "numeric",
                                });
                                psnewt = new Date().toLocaleString("LK", {
                                    timeZone: TIME_ZONE
                                }).split(" ")[1];
                                const biography = AUTO_BIO.replace('&time', psnewt).replace('&date', pstime);
                                await conn.updateProfileStatus(biography);
                            }, 1000 * 60);
                        };
                        setInterval(async () => {
                            let currentTime = new Date().toLocaleString("LK", {
                                timeZone: TIME_ZONE,
                                hour12: false,
                            }).split(" ")[1];
                            currentTime = currentTime.split(':');
                            currentTime = currentTime[0] + ':' + currentTime[1];
                            const mute = await getMute();
                            const unmute = await getUnMute();
                            mute.map(async({status,time,jid})=>{
                                console.log(currentTime,time)
                                if(status && time && currentTime == time) {
                                    await conn.groupSettingUpdate(jid, "announcement");
                                }
                            })
                            unmute.map(async({status,time,jid})=>{
                                if(status && time && currentTime == time) {
                                    await conn.groupSettingUpdate(jid, "not_announcement");
                                }
                            })
                        }, 1000 * 55);
                    }
                    isRunned = true;
                    // all link ban
                    if (m.isGroup) {
                        const text = (m.client.displayText || 'ßßßßß').toLowerCase();
                        const actionLink = await getAntiLink(m.jid);
                        const actionWord = await getAntiWords(m.jid);
                        const resone = "The law in the group was not accepted";
                        if (actionLink.status && !m.client.isCreator) {
                            if (text.includes('http')) {
                                if (!await isBotAdmin(m)) return;
                                if (await isAdmin(m)) return;
                                const {
                                    action
                                } = actionLink;
                                if (action == "warn") {
                                    await conn.sendMessage(m.from, {
                                        delete: m.key
                                    })
                                    const res = await setWarn(m.sender, m.jid, resone)
                                    let remains = WARNCOUND - res.count;
                                    let warnmsg = `❏─────[ ᴡᴀʀɴɪɴɢ ]─────❏
│ User :- @${res.user.replace(/[^0-9]/g,'')}
❏───────────────────❏
┏─────── INFO ───────❏
│ Reason :- ${res.reason}
│ Count :- ${res.count}
│ Remaining :- ${remains}
┗•─────────────────❏`
                                    await m.client.sendMessage(m.jid, {
                                        text: warnmsg,
                                        mentions: [res.user]
                                    })
                                    if (remains <= 0) {
                                        await ResetWarn(m.sender, m.jid)
                                        await conn.groupParticipantsUpdate(m.jid, [m.sender], "remove");
                                    }
                                } else if (action == "kick") {
                                    await conn.sendMessage(m.from, {
                                        delete: m.key
                                    })
                                    await conn.groupParticipantsUpdate(m.jid, [m.sender], "remove");
                                } else {
                                    await conn.sendMessage(m.from, {
                                        delete: m.key
                                    })
                                    await m.reply("_Links Not allowed in this group_")
                                }
                            }
                        }
                        if (actionWord.status && !m.client.isCreator) {
                            if (!await isBotAdmin(m)) return;
                            if (await isAdmin(m)) return;
                            const notAllowed = actionWord.word ? actionWord.word.split(',') || [actionWord.word] : [];
                            notAllowed.map(async (word) => {
                                if (text.includes(word)) {
                                    if (actionWord.action == "warn") {
                                        await conn.sendMessage(m.from, {
                                            delete: m.key
                                        })
                                        const res = await setWarn(m.sender, m.jid, resone)
                                        let remains = WARNCOUND - res.count;
                                        let warnmsg = `❏─────[ ᴡᴀʀɴɪɴɢ ]─────❏
│ User :- @${res.user.replace(/[^0-9]/g,'')}
❏───────────────────❏
┏─────── INFO ───────❏
│ Reason :- ${res.reason}
│ Count :- ${res.count}
│ Remaining :- ${remains}
┗•─────────────────❏`
                                        await m.client.sendMessage(m.jid, {
                                            text: warnmsg,
                                            mentions: [res.user]
                                        })
                                        if (remains <= 0) {
                                            await ResetWarn(m.sender, m.jid)
                                            await conn.groupParticipantsUpdate(m.jid, [m.sender], "remove");
                                        }
                                    } else if (actionWord.action == "kick") {
                                        await conn.sendMessage(m.from, {
                                            delete: m.key
                                        })
                                        await conn.groupParticipantsUpdate(m.jid, [m.sender], "remove");
                                    } else {
                                        await conn.sendMessage(m.from, {
                                            delete: m.key
                                        })
                                    }
                                }
                            })
                        }
                    }
                    //end
                    //automatic reaction
                    if (!em_ed) {
                        if (REACT == 'true' && m && !isReact) {
                            if (m.client.body.match(/\p{EPres}|\p{ExtPict}/gu)) {
                                await sleep(100)
                                await conn.sendMessage(m.from, {
                                    react: {
                                        text: m.client.body.match(/\p{EPres}|\p{ExtPict}/gu)[0],
                                        key: m.key
                                    }
                                });
                            } else {
                                let reactArray = ['💘', '💝', '💖', '💗', '💓', '💞', '💕', '💟', '❣️', '💔', '❤️', '🧡', '💛', '💚', '💙', '💜', '🤎', '🖤', '🤍', '❤️‍', '🔥', '❤️‍', '🩹', '💯', '♨️', '💢', '💬', '👁️‍🗨️', '🗨️', '🗯️', '💭', '💤', '🌐', '♠️', '♥️', '♦️', '♣️', '🃏', '🀄️', '🎴', '🎭️', '🔇', '🔈️', '🔉', '🔊', '🔔', '🔕', '🎼', '🎵', '🎶', '💹', '🏧', '🚮', '🚰', '♿️', '🚹️', '🚺️', '🚻', '🚼️', '🚾', '🛂', '🛃', '🛄', '🛅', '⚠️', '🚸', '⛔️', '🚫', '🚳', '🚭️', '🚯', '🚱', '🚷', '📵', '🔞', '☢️', '☣️', '⬆️', '↗️', '➡️', '↘️', '⬇️', '↙️', '⬅️', '↖️', '↕️', '↔️', '↩️', '↪️', '⤴️', '⤵️', '🔃', '🔄', '🔙', '🔚', '🔛', '🔜', '🔝', '🛐', '⚛️', '🕉️', '✡️', '☸️', '☯️', '✝️', '☦️', '☪️', '☮️', '🕎', '🔯', '♈️', '♉️', '♊️', '♋️', '♌️', '♍️', '♎️', '♏️', '♐️', '♑️', '♒️', '♓️', '⛎', '🔀', '🔁', '🔂', '▶️', '⏩️', '⏭️', '⏯️', '◀️', '⏪️', '⏮️', '🔼', '⏫', '🔽', '⏬', '⏸️', '⏹️', '⏺️', '⏏️', '🎦', '🔅', '🔆', '📶', '📳', '📴', '♀️', '♂️', '⚧', '✖️', '➕', '➖', '➗', '♾️', '‼️', '⁉️', '❓️', '❔', '❕', '❗️', '〰️', '💱', '💲', '⚕️', '♻️', '⚜️', '🔱', '📛', '🔰', '⭕️', '✅', '☑️', '✔️', '❌', '❎', '➰', '➿', '〽️', '✳️', '✴️', '❇️', '©️', '®️', '™️', '#️⃣', '*️⃣', '0️⃣', '1️⃣', '2️⃣', '3️⃣', '4️⃣', '5️⃣', '6️⃣', '7️⃣', '8️⃣', '9️⃣', '🔟', '🔠', '🔡', '🔢', '🔣', '🔤', '🅰️', '🆎', '🅱️', '🆑', '🆒', '🆓', 'ℹ️', '🆔', 'Ⓜ️', '🆕', '🆖', '🅾️', '🆗', '🅿️', '🆘', '🆙', '🆚', '🈁', '🈂️', '🈷️', '🈶', '🈯️', '🉐', '🈹', '🈚️', '🈲', '🉑', '🈸', '🈴', '🈳', '㊗️', '㊙️', '🈺', '🈵', '🔴', '🟠', '🟡', '🟢', '🔵', '🟣', '🟤', '⚫️', '⚪️', '🟥', '🟧', '🟨', '🟩', '🟦', '🟪', '🟫', '⬛️', '⬜️', '◼️', '◻️', '◾️', '◽️', '▪️', '▫️', '🔶', '🔷', '🔸', '🔹', '🔺', '🔻', '💠', '🔘', '🔳', '🔲', '🕛️', '🕧️', '🕐️', '🕜️', '🕑️', '🕝️', '🕒️', '🕞️', '🕓️', '🕟️', '🕔️', '🕠️', '🕕️', '🕡️', '🕖️', '🕢️', '🕗️', '🕣️', '🕘️', '🕤️', '🕙️', '🕥️', '🕚️', '🕦️', '*️', '#️', '0️', '1️', '2️', '3️', '4️', '5️', '6️', '7️', '8️', '9️', '🛎️', '🧳', '⌛️', '⏳️', '⌚️', '⏰', '⏱️', '⏲️', '🕰️', '🌡️', '🗺️', '🧭', '🎃', '🎄', '🧨', '🎈', '🎉', '🎊', '🎎', '🎏', '🎐', '🎀', '🎁', '🎗️', '🎟️', '🎫', '🔮', '🧿', '🎮️', '🕹️', '🎰', '🎲', '♟️', '🧩', '🧸', '🖼️', '🎨', '🧵', '🧶', '👓️', '🕶️', '🥽', '🥼', '🦺', '👔', '👕', '👖', '🧣', '🧤', '🧥', '🧦', '👗', '👘', '🥻', '🩱', '🩲', '🩳', '👙', '👚', '👛', '👜', '👝', '🛍️', '🎒', '👞', '👟', '🥾', '🥿', '👠', '👡', '🩰', '👢', '👑', '👒', '🎩', '🎓️', '🧢', '⛑️', '📿', '💄', '💍', '💎', '📢', '📣', '📯', '🎙️', '🎚️', '🎛️', '🎤', '🎧️', '📻️', '🎷', '🎸', '🎹', '🎺', '🎻', '🪕', '🥁', '📱', '📲', '☎️', '📞', '📟️', '📠', '🔋', '🔌', '💻️', '🖥️', '🖨️', '⌨️', '🖱️', '🖲️', '💽', '💾', '💿️', '📀', '🧮', '🎥', '🎞️', '📽️', '🎬️', '📺️', '📷️', '📸', '📹️', '📼', '🔍️', '🔎', '🕯️', '💡', '🔦', '🏮', '🪔', '📔', '📕', '📖', '📗', '📘', '📙', '📚️', '📓', '📒', '📃', '📜', '📄', '📰', '🗞️', '📑', '🔖', '🏷️', '💰️', '💴', '💵', '💶', '💷', '💸', '💳️', '🧾', '✉️', '💌', '📧', '🧧', '📨', '📩', '📤️', '📥️', '📦️', '📫️', '📪️', '📬️', '📭️', '📮', '🗳️', '✏️', '✒️', '🖋️', '🖊️', '🖌️', '🖍️', '📝', '💼', '📁', '📂', '🗂️', '📅', '📆', '🗒️', '🗓️', '📇', '📈', '📉', '📊', '📋️', '📌', '📍', '📎', '🖇️', '📏', '📐', '✂️', '🗃️', '🗄️', '🗑️', '🔒️', '🔓️', '🔏', '🔐', '🔑', '🗝️', '🔨', '🪓', '⛏️', '⚒️', '🛠️', '🗡️', '⚔️', '💣️', '🏹', '🛡️', '🔧', '🔩', '⚙️', '🗜️', '⚖️', '🦯', '🔗', '⛓️', '🧰', '🧲', '⚗️', '🧪', '🧫', '🧬', '🔬', '🔭', '📡', '💉', '🩸', '💊', '🩹', '🩺', '🚪', '🛏️', '🛋️', '🪑', '🚽', '🚿', '🛁', '🪒', '🧴', '🧷', '🧹', '🧺', '🧻', '🧼', '🧽', '🧯', '🛒', '🚬', '⚰️', '⚱️', '🏺', '🕳️', '🏔️', '⛰️', '🌋', '🗻', '🏕️', '🏖️', '🏜️', '🏝️', '🏟️', '🏛️', '🏗️', '🧱', '🏘️', '🏚️', '🏠️', '🏡', '🏢', '🏣', '🏤', '🏥', '🏦', '🏨', '🏩', '🏪', '🏫', '🏬', '🏭️', '🏯', '🏰', '💒', '🗼', '🗽', '⛪️', '🕌', '🛕', '🕍', '⛩️', '🕋', '⛲️', '⛺️', '🌁', '🌃', '🏙️', '🌄', '🌅', '🌆', '🌇', '🌉', '🗾', '🏞️', '🎠', '🎡', '🎢', '💈', '🎪', '🚂', '🚃', '🚄', '🚅', '🚆', '🚇️', '🚈', '🚉', '🚊', '🚝', '🚞', '🚋', '🚌', '🚍️', '🚎', '🚐', '🚑️', '🚒', '🚓', '🚔️', '🚕', '🚖', '🚗', '🚘️', '🚙', '🚚', '🚛', '🚜', '🏎️', '🏍️', '🛵', '🦽', '🦼', '🛺', '🚲️', '🛴', '🛹', '🚏', '🛣️', '🛤️', '🛢️', '⛽️', '🚨', '🚥', '🚦', '🛑', '🚧', '⚓️', '⛵️', '🛶', '🚤', '🛳️', '⛴️', '🛥️', '🚢', '✈️', '🛩️', '🛫', '🛬', '🪂', '💺', '🚁', '🚟', '🚠', '🚡', '🛰️', '🚀', '🛸', '🎆', '🎇', '🎑', '🗿', '⚽️', '⚾️', '🥎', '🏀', '🏐', '🏈', '🏉', '🎾', '🥏', '🎳', '🏏', '🏑', '🏒', '🥍', '🏓', '🏸', '🥊', '🥋', '🥅', '⛳️', '⛸️', '🎣', '🤿', '🎽', '🎿', '🛷', '🥌', '🎯', '🪀', '🪁', '🎱', '🎖️', '🏆️', '🏅', '🥇', '🥈', '🥉', '🍇', '🍈', '🍉', '🍊', '🍋', '🍌', '🍍', '🥭', '🍎', '🍏', '🍐', '🍑', '🍒', '🍓', '🥝', '🍅', '🥥', '🥑', '🍆', '🥔', '🥕', '🌽', '🌶️', '🥒', '🥬', '🥦', '🧄', '🧅', '🍄', '🥜', '🌰', '🍞', '🥐', '🥖', '🥨', '🥯', '🥞', '🧇', '🧀', '🍖', '🍗', '🥩', '🥓', '🍔', '🍟', '🍕', '🌭', '🥪', '🌮', '🌯', '🥙', '🧆', '🥚', '🍳', '🥘', '🍲', '🥣', '🥗', '🍿', '🧈', '🧂', '🥫', '🍱', '🍘', '🍙', '🍚', '🍛', '🍜', '🍝', '🍠', '🍢', '🍣', '🍤', '🍥', '🥮', '🍡', '🥟', '🥠', '🥡', '🍦', '🍧', '🍨', '🍩', '🍪', '🎂', '🍰', '🧁', '🥧', '🍫', '🍬', '🍭', '🍮', '🍯', '🍼', '🥛', '☕️', '🍵', '🍶', '🍾', '🍷', '🍸️', '🍹', '🍺', '🍻', '🥂', '🥃', '🥤', '🧃', '🧉', '🧊', '🥢', '🍽️', '🍴', '🥄', '🔪', '🐵', '🐒', '🦍', '🦧', '🐶', '🐕️', '🦮', '🐕‍', '🦺', '🐩', '🐺', '🦊', '🦝', '🐱', '🐈️', '🐈‍', '🦁', '🐯', '🐅', '🐆', '🐴', '🐎', '🦄', '🦓', '🦌', '🐮', '🐂', '🐃', '🐄', '🐷', '🐖', '🐗', '🐽', '🐏', '🐑', '🐐', '🐪', '🐫', '🦙', '🦒', '🐘', '🦏', '🦛', '🐭', '🐁', '🐀', '🐹', '🐰', '🐇', '🐿️', '🦔', '🦇', '🐻', '🐻‍', '❄️', '🐨', '🐼', '🦥', '🦦', '🦨', '🦘', '🦡', '🐾', '🦃', '🐔', '🐓', '🐣', '🐤', '🐥', '🐦️', '🐧', '🕊️', '🦅', '🦆', '🦢', '🦉', '🦩', '🦚', '🦜', '🐸', '🐊', '🐢', '🦎', '🐍', '🐲', '🐉', '🦕', '🦖', '🐳', '🐋', '🐬', '🐟️', '🐠', '🐡', '🦈', '🐙', '🦑', '🦀', '🦞', '🦐', '🦪', '🐚', '🐌', '🦋', '🐛', '🐜', '🐝', '🐞', '🦗', '🕷️', '🕸️', '🦂', '🦟', '🦠', '💐', '🌸', '💮', '🏵️', '🌹', '🥀', '🌺', '🌻', '🌼', '🌷', '🌱', '🌲', '🌳', '🌴', '🌵', '🎋', '🎍', '🌾', '🌿', '☘️', '🍀', '🍁', '🍂', '🍃', '🌍️', '🌎️', '🌏️', '🌑', '🌒', '🌓', '🌔', '🌕️', '🌖', '🌗', '🌘', '🌙', '🌚', '🌛', '🌜️', '☀️', '🌝', '🌞', '🪐', '💫', '⭐️', '🌟', '✨', '🌠', '🌌', '☁️', '⛅️', '⛈️', '🌤️', '🌥️', '🌦️', '🌧️', '🌨️', '🌩️', '🌪️', '🌫️', '🌬️', '🌀', '🌈', '🌂', '☂️', '☔️', '⛱️', '⚡️', '❄️', '☃️', '⛄️', '☄️', '🔥', '💧', '🌊', '💥', '💦', '💨', '😀', '😃', '😄', '😁', '😆', '😅', '🤣', '😂', '🙂', '🙃', '😉', '😊', '😇', '🥰', '😍', '🤩', '😘', '😗', '☺️', '😚', '😙', '😋', '😛', '😜', '🤪', '😝', '🤑', '🤗', '🤭', '🤫', '🤔', '🤐', '🤨', '😐️', '😑', '😶', '😏', '😒', '🙄', '😬', '🤥', '😌', '😔', '😪', '😮‍', '💨', '🤤', '😴', '😷', '🤒', '🤕', '🤢', '🤮', '🤧', '🥵', '🥶', '😶‍', '🌫️', '🥴', '😵‍', '💫', '😵', '🤯', '🤠', '🥳', '😎', '🤓', '🧐', '😕', '😟', '🙁', '☹️', '😮', '😯', '😲', '😳', '🥺', '😦', '😧', '😨', '😰', '😥', '😢', '😭', '😱', '😖', '😣', '😞', '😓', '😩', '😫', '🥱', '😤', '😡', '😠', '🤬', '😈', '👿', '💀', '☠️', '💩', '🤡', '👹', '👺', '👻', '👽️', '👾', '🤖', '😺', '😸', '😹', '😻', '😼', '😽', '🙀', '😿', '😾', '🙈', '🙉', '🙊', '👋', '🤚', '🖐️', '✋', '🖖', '👌', '🤏', '✌️', '🤞', '🤟', '🤘', '🤙', '👈️', '👉️', '👆️', '🖕', '👇️', '☝️', '👍️', '👎️', '✊', '👊', '🤛', '🤜', '👏', '🙌', '👐', '🤲', '🤝', '🙏', '✍️', '💅', '🤳', '💪', '🦾', '🦿', '🦵', '🦶', '👂️', '🦻', '👃', '🧠', '🦷', '🦴', '👀', '👁️', '👅', '👄', '💋', '👶', '🧒', '👦', '👧', '🧑', '👨', '👩', '🧔', '🧔‍♀️', '🧔‍♂️', '🧑', '👨‍', '🦰', '👩‍', '🦰', '🧑', '👨‍', '🦱', '👩‍', '🦱', '🧑', '👨‍', '🦳', '👩‍', '🦳', '🧑', '👨‍', '🦲', '👩‍', '🦲', '👱', '👱‍♂️', '👱‍♀️', '🧓', '👴', '👵', '🙍', '🙍‍♂️', '🙍‍♀️', '🙎', '🙎‍♂️', '🙎‍♀️', '🙅', '🙅‍♂️', '🙅‍♀️', '🙆', '🙆‍♂️', '🙆‍♀️', '💁', '💁‍♂️', '💁‍♀️', '🙋', '🙋‍♂️', '🙋‍♀️', '🧏', '🧏‍♂️', '🧏‍♀️', '🙇', '🙇‍♂️', '🙇‍♀️', '🤦', '🤦‍♂️', '🤦‍♀️', '🤷', '🤷‍♂️', '🤷‍♀️', '🧑‍⚕️', '👨‍⚕️', '👩‍⚕️', '🧑‍🎓', '👨‍🎓', '👩‍🎓', '🧑‍🏫', '👨‍🏫', '👩‍🏫', '🧑‍⚖️', '👨‍⚖️', '👩‍⚖️', '🧑‍🌾', '👨‍🌾', '👩‍🌾', '🧑‍🍳', '👨‍🍳', '👩‍🍳', '🧑‍🔧', '👨‍🔧', '👩‍🔧', '🧑‍🏭', '👨‍🏭', '👩‍🏭', '🧑‍💼', '👨‍💼', '👩‍💼', '🧑‍🔬', '👨‍🔬', '👩‍🔬', '🧑‍💻', '👨‍💻', '👩‍💻', '🧑‍🎤', '👨‍🎤', '👩‍🎤', '🧑‍🎨', '👨‍🎨', '👩‍🎨', '🧑‍✈️', '👨‍✈️', '👩‍✈️', '🧑‍🚀', '👨‍🚀', '👩‍🚀', '🧑‍🚒', '👨‍🚒', '👩‍🚒', '👮', '👮‍♂️', '👮‍♀️', '🕵️', '🕵️‍♂️', '🕵️‍♀️', '💂', '💂‍♂️', '💂‍♀️', '👷', '👷‍♂️', '👷‍♀️', '🤴', '👸', '👳', '👳‍♂️', '👳‍♀️', '👲', '🧕', '🤵', '🤵‍♂️', '🤵‍♀️', '👰', '👰‍♂️', '👰‍♀️', '🤰', '🤱', '👩‍', '🍼', '👨‍', '🍼', '🧑‍', '🍼', '👼', '🎅', '🤶', '🧑‍', '🎄', '🦸', '🦸‍♂️', '🦸‍♀️', '🦹', '🦹‍♂️', '🦹‍♀️', '🧙', '🧙‍♂️', '🧙‍♀️', '🧚', '🧚‍♂️', '🧚‍♀️', '🧛', '🧛‍♂️', '🧛‍♀️', '🧜', '🧜‍♂️', '🧜‍♀️', '🧝', '🧝‍♂️', '🧝‍♀️', '🧞', '🧞‍♂️', '🧞‍♀️', '🧟', '🧟‍♂️', '🧟‍♀️', '💆', '💆‍♂️', '💆‍♀️', '💇', '💇‍♂️', '💇‍♀️', '🚶', '🚶‍♂️', '🚶‍♀️', '🧍', '🧍‍♂️', '🧍‍♀️', '🧎', '🧎‍♂️', '🧎‍♀️', '🧑‍', '🦯', '👨‍', '🦯', '👩‍', '🦯', '🧑‍', '🦼', '👨‍', '🦼', '👩‍', '🦼', '🧑‍', '🦽', '👨‍', '🦽', '👩‍', '🦽', '🏃', '🏃‍♂️', '🏃‍♀️', '💃', '🕺', '🕴️', '👯', '👯‍♂️', '👯‍♀️', '🧖', '🧖‍♂️', '🧖‍♀️', '🧗', '🧗‍♂️', '🧗‍♀️', '🤺', '🏇', '⛷️', '🏂️', '🏌️', '🏌️‍♂️', '🏌️‍♀️', '🏄️', '🏄‍♂️', '🏄‍♀️', '🚣', '🚣‍♂️', '🚣‍♀️', '🏊️', '🏊‍♂️', '🏊‍♀️', '⛹️', '⛹️‍♂️', '⛹️‍♀️', '🏋️', '🏋️‍♂️', '🏋️‍♀️', '🚴', '🚴‍♂️', '🚴‍♀️', '🚵', '🚵‍♂️', '🚵‍♀️', '🤸', '🤸‍♂️', '🤸‍♀️', '🤼', '🤼‍♂️', '🤼‍♀️', '🤽', '🤽‍♂️', '🤽‍♀️', '🤾', '🤾‍♂️', '🤾‍♀️', '🤹', '🤹‍♂️', '🤹‍♀️', '🧘', '🧘‍♂️', '🧘‍♀️', '🛀', '🛌', '🧑‍', '🤝‍', '🧑', '👭', '👫', '👬', '💏', '👩‍❤️‍💋‍👨', '👨‍❤️‍💋‍👨', '👩‍❤️‍💋‍👩', '💑', '👩‍❤️‍👨', '👨‍❤️‍👨', '👩‍❤️‍👩', '👪️', '👨‍👩‍👦', '👨‍👩‍👧', '👨‍👩‍👧‍👦', '👨‍👩‍👦‍👦', '👨‍👩‍👧‍👧', '👨‍👨‍👦', '👨‍👨‍👧', '👨‍👨‍👧‍👦', '👨‍👨‍👦‍👦', '👨‍👨‍👧‍👧', '👩‍👩‍👦', '👩‍👩‍👧', '👩‍👩‍👧‍👦', '👩‍👩‍👦‍👦', '👩‍👩‍👧‍👧', '👨‍👦', '👨‍👦‍👦', '👨‍👧', '👨‍👧‍👦', '👨‍👧‍👧', '👩‍👦', '👩‍👦‍👦', '👩‍👧', '👩‍👧‍👦', '👩‍👧‍👧', '🗣️', '👤', '👥', '👣'];
                                let getType = reactArray[Math.floor(Math.random() * reactArray.length)];
                                await sleep(100)
                                await conn.sendMessage(m.from, {
                                    react: {
                                        text: getType,
                                        key: m.key
                                    }
                                });
                            }
                        } else if (REACT != 'true' && m && REACT_EMOJI == "true" && !isReact) {
                            if (m.client.body.match(/\p{EPres}|\p{ExtPict}/gu)) {
                                await conn.sendMessage(m.from, {
                                    react: {
                                        text: m.client.body.match(/\p{EPres}|\p{ExtPict}/gu)[0],
                                        key: m.key
                                    }
                                });
                            }
                        }
                    }
                });
            } else if (connection === "close") {
                console.log("Connection closed with bot. Please put New Session ID again.");
                await sleep(3000)
                WhatsBotConnect();
            }
        });
        setInterval(async () => {
            await removeFile("");
            await removeFile("media");
        }, 1000 * 30);
    } catch (err) {
        console.log(err)
    }
} // function closing
app.get("/", (req, res) => {
    res.send("Hello Inrl started\nversion: " + require("./package.json").version);
});
app.listen(port, () => console.log(`Inrl Server listening on port http://localhost:${port}`));
setTimeout(() => {
    WhatsBotConnect();
}, 3000);
