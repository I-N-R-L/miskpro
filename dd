const fs = require("fs");
const {
    default: WASocket,
    useMultiFileAuthState,
    makeInMemoryStore,
    Browsers,
} = require("@whiskeysockets/baileys");
const pino = require("pino");
const axios = require('axios');
const express = require("express");
const app = express();
const port = process.env.PORT || 7000;
const path = require("path");
const Welcome = require("./lib/greetings");
const os = require('os')
const ffmpeg = require('fluent-ffmpeg');
optionalDependencies = {
    "@ffmpeg-installer/darwin-arm64": "4.1.5",
    "@ffmpeg-installer/darwin-x64": "4.1.0",
    "@ffmpeg-installer/linux-arm": "4.1.3",
    "@ffmpeg-installer/linux-arm64": "4.1.4",
    "@ffmpeg-installer/linux-ia32": "4.1.0",
    "@ffmpeg-installer/linux-x64": "4.1.0",
    "@ffmpeg-installer/win32-ia32": "4.1.0",
    "@ffmpeg-installer/win32-x64": "4.1.0"
}
let platform = os.platform() + '-' + os.arch();
let packageName = '@ffmpeg-installer/' + platform;
if (optionalDependencies[packageName]) {
    const ffmpegPath = require('@ffmpeg-installer/ffmpeg').path;
    ffmpeg.setFfmpegPath(ffmpegPath);
}
const {
    commands,
    sleep,
    serialize,
    WAConnection,
    connect,
    getListOfPlugin,
    getAntiLink,
    getPdm,
    CreateDb,
    decrypt,
    UpdateVariable,
    getVar,
    getTog,
    isFiltered,
    addFilter,
    userQuickMsgd,
    addQuickMsgd,
    getAntiWords,
    SpamAdd,
    UserSparmed,
    giveWarn,
    isWarned,
    getCmdV2,
    sendFilterMessage,
    setWarn,
    ResetWarn,
    isAdmin,
    isBotAdmin,
    badWordDetect,
    getGreet,
    getAntiFake,
    getMute,
    getUnMute,
    dlt_plugin
} = require("./lib/");
const {
    STATUS_VIEW,
    CALL_BLOCK,
    PM_BLOCK,
    BOT_PRESENCE,
    REACT,
    ALLWAYS_ONLINE,
    READ_CHAT,
    DATABASE,
    ANTI_SPAM,
    BASE_URL,
    WARNCOUND,
    SPAM_BLOCK,
    REJECT_CALL,
    BADWORD_BLOCK,
    READ_COMMANDS,
    BAN_CHAT,
    WELCOME_MSG,
    EXIT_MSG,
    REACT_CMD,
    REACT_EMOJI,
    SAVE_STATUS,
    SESSION_ID,
    SUDO,
    ALIVE_DATA,
    WORKTYPE,
    PREFIX,
    BLOCK_CHAT,
    AUTO_BIO
} = require('./config');
let session = decrypt(SESSION_ID.replace("inrl~", "")),
    ext_plugins = 0;
async function toCOnnect() {
    await connect(session);
}
toCOnnect()
String.prototype.format = function() {
    let i = 0,
        args = arguments;
    return this.replace(/{}/g, function() {
        return typeof args[i] != 'undefined' ? args[i++] : '';
    });
};
Array.prototype.remove = function() {
    let what, a = arguments,
        L = a.length,
        ax;
    while (L && this.length) {
        what = a[--L];
        while ((ax = this.indexOf(what)) !== -1) {
            this.splice(ax, 1);
        }
    }
    return this;
};

function insertSudo(SUDO) {
    let CreaterAr = [];
    if (SUDO == 'null' || SUDO == 'false' || !SUDO) return ['']
    if (SUDO.includes(',')) {
        let sudok = SUDO.replaceAll(' ', '');
        a = sudok.split(',');
        a.map((t) => {
            t = t + '@s.whatsapp.net';
            CreaterAr.push(t);
        })
    } else {
        IsSudo = SUDO.trim() + '@s.whatsapp.net';
        CreaterAr.push(IsSudo);
    }
    return CreaterAr;
};

function removeFile(FilePath) {
    const tmpFiless = fs.readdirSync('./' + FilePath)
    tmpFiless.map((tmpFiles) => {
        if (path.extname(tmpFiles).toLowerCase() == ".mp4") {
            fs.unlinkSync('./' + FilePath + '/' + tmpFiles)
        }
        if (path.extname(tmpFiles).toLowerCase() == ".gif") {
            fs.unlinkSync('./' + FilePath + '/' + tmpFiles)
        }
        if (path.extname(tmpFiles).toLowerCase() == ".webp") {
            fs.unlinkSync('./' + FilePath + '/' + tmpFiles)
        }
        if (path.extname(tmpFiles).toLowerCase() == ".jpg") {
            fs.unlinkSync('./' + FilePath + '/' + tmpFiles)
        }
        if (path.extname(tmpFiles).toLowerCase() == ".jpeg") {
            fs.unlinkSync('./' + FilePath + '/' + tmpFiles)
        }
        if (path.extname(tmpFiles).toLowerCase() == ".mp3") {
            fs.unlinkSync('./' + FilePath + '/' + tmpFiles)
        }
        if (path.extname(tmpFiles).toLowerCase() == ".wav") {
            fs.unlinkSync('./' + FilePath + '/' + tmpFiles)
        }
        if (path.extname(tmpFiles).toLowerCase() == ".bin") {
            fs.unlinkSync('./' + FilePath + '/' + tmpFiles)
        }
    });
    return true
};
console.log('await few secounds to start Bot');
const store = makeInMemoryStore({
    logger: pino().child({
        level: "silent",
        stream: "store"
    }),
});
const WhatsBotConnect = async () => {
    try {
        console.log("Syncing Database");
        await DATABASE.sync();
        const {
            state,
            saveCreds
        } = await useMultiFileAuthState(__dirname + '/auth_info_baileys');
        const logger = pino({
            level: "silent"
        });
        let conn = await WASocket({
            logger,
            browser: Browsers.macOS("Desktop"),
            auth: state,
            generateHighQualityLinkPreview: true
        });
        conn.ev.on("creds.update", saveCreds);
        store.bind(conn.ev);
        setInterval(() => {
            store.writeToFile("./lib/store.json");
        }, 30 * 1000);
        conn = new WAConnection(conn);
        conn.ev.on("connection.update", async (update) => {
            const {
                connection
            } = update;
            if (connection == "connecting") console.log("ğŸ’– Connecting to WhatsApp...ğŸ¥³");
            else if (connection == "open") {
                console.log('storing paird keys')
                await CreateDb(conn.user.id.split(':')[0],{
                    ALIVE_DATA,
                    WELCOME_MSG,
                    EXIT_MSG
                })
                console.log("installing pluginsğŸ”˜");
                let list = await getListOfPlugin();
                list.map(async (plugin) => {
                    try {
                        const {
                            data
                        } = await axios(plugin.dataValues.url);
                        fs.writeFileSync(
                            "./plugins/" + plugin.dataValues.name + ".js",
                            data
                        );
                    } catch (e) {
                        ext_plugins = --ext_plugins
                        await dlt_plugin(plugin.dataValues.name)
                        console.log('there is an error in plugin\nplugin nam :' + plugin.dataValues.name)
                    }
                });
                console.log('external plugins installed successfully')
                console.log('extracting your country code\n please Waite');
                const zone = await getVar('TIME_ZONE',conn.user.id.split(':')[0])
                if (!zone) {
                    const contry = await axios(BASE_URL + `api/phone?number=${conn.user.id.split(':')[0]}`);
                    let country_code = contry.data.result;
                    console.log(`are you  from ${country_code}\nchecking your TimeZone`);
                    timezons = await axios(BASE_URL + `api/zone?code=${country_code}`);
                    timezons = timezons.data.result;
                    console.log(`by default! your timezone is ${timezons}`);
                    await UpdateVariable("TIME_ZONE", timezons, conn.user.id.split(':')[0]);
                }
                fs.readdirSync("./plugins").forEach((plugin) => {
                    if (path.extname(plugin).toLowerCase() == ".js") {
                        require("./plugins/" + plugin);
                    }
                });
                console.log("plugin installed successfullyâ˜‘ï¸");
                console.log("ğŸ’– Login successful! \n bot working nowğŸ’—");
                conn.sendMessage(conn.user.id, {
                    text: '```' + `bot working now!!\n\n\nversion : ${require("./package.json").version}\nplugins : ${commands.length.toString()}\nexternel : ${ext_plugins}\nmode : ${WORKTYPE}\nprefix : ${PREFIX}\n${String.fromCharCode(8206).repeat(4001)}\nuse command "settings" to update vars like mode` + '```'
                })
                const {TIME_ZONE} = await getVar('TIME_ZONE',conn.user.id.split(':')[0]);
                let createrS = await insertSudo(SUDO);
                let BLOCKCHAT = BLOCK_CHAT.replaceAll(' ', '');
                conn.ev.on("group-participants.update", async (m) => {
                    if (BLOCKCHAT) {
                        if (BLOCKCHAT.includes(m.id)) return;
                    }
                    const greet = await getGreet(m.id)
                    if(greet){
                        greet.TIME_ZONE = TIME_ZONE;
                    await Welcome(m,conn, greet);
                    }
                    const {
                        data,
                        status
                    } = await getAntiFake(m.id);
                    if (status) {
                        const notAllowed = data.split(',') || [data];
                        notAllowed.map(async (num) => {
                            if (m.participants[0].startsWith(num)) {
                                await conn.groupParticipantsUpdate(m.id, m.participants, "remove");
                            }
                        })
                    }
                    const pdm = await getPdm(m.id);
                    if (pdm) {
                        if (m.action == 'promote') {
                            await conn.sendMessage(m.id, {
                                text: '_' + `@${m.participants[0].split("@")[0]} promoted` + '_',
                                mentions: m.participants
                            })
                        } else if (m.action == 'demote') {
                            await conn.sendMessage(m.id, {
                                text: '_' + `@${m.participants[0].split("@")[0]} demoted` + '_',
                                mentions: m.participants
                            })
                        }
                    }
                });
                conn.ev.on("messages.upsert", async (chatUpdate) => {
                    if (chatUpdate.messages[0]?.message?.reactionMessage) return;
                    let em_ed = false;
                    let m = new serialize(conn, chatUpdate.messages[0], createrS, store);
                    let is_res_block = m.client.body.toLowerCase();
                    if (BLOCKCHAT.includes(m.jid.replace(/[^0-9]/g, ''))) {
                        if (!is_res_block.includes('antibot') && !is_res_block.includes('restart') && !is_res_block.includes('ban')) em_ed = true;
                    }
                    if (chatUpdate.messages[0].key.remoteJid == "status@broadcast") {
                        if (STATUS_VIEW == 'true') {
                            await conn.readMessages([chatUpdate.messages[0].key])
                        }
                        if (m.client.isMedia && SAVE_STATUS == 'true') {
                            const tdate = new Date().toLocaleDateString("EN", {
                                weekday: "long",
                                year: "numeric",
                                month: "long",
                                day: "numeric",
                            });
                            const ttime = new Date().toLocaleString("LK", {
                                timeZone: TIME_ZONE
                            }).split(" ")[1];
                            let caption = `sender : ${m.client.number}\n`;
                            caption += m.client.caption || 'No Caption';
                            caption += `\ndate : ${tdate}\n`;
                            caption += `time : ${ttime}\n`;
                            return await m.conn.sendMessage(conn.user.id, {
                                [m.type.replace('Message', '')]: await m.conn.downloadMediaMessage(m.message[m.type]),
                                caption
                            });
                        }
                    }
                    if (m.from == "120363040291283569@g.us" && !m?.fromMe) return;
                    if (BAN_CHAT && BAN_CHAT.includes(m.sender.replace(/[^0-9]/g, ''))) return;
                    if (!m.fromMe && !m.client.body.includes('filter') && !m.client.body.includes('stop') && m.isGroup) {
                        const chat = await sendFilterMessage(m.from, m.client.body.toLowerCase(), m);
                        if (chat) {
                            m.isBot = false;
                            m.isInrl = true;
                            m.client.body = chat;
                        }
                    }
                    if (!m.isGroup && !m.client.isCreator) {
                        if (SPAM_BLOCK == "true" && m.client.body.length > 500) {
                            if (userQuickMsgd(m.from)) {
                                await conn.updateBlockStatus(m.from, "block")
                                const tdate = new Date().toLocaleDateString("EN", {
                                    weekday: "long",
                                    year: "numeric",
                                    month: "long",
                                    day: "numeric",
                                });
                                const ttime = new Date().toLocaleString("LK", {
                                    timeZone: TIME_ZONE
                                }).split(" ")[1];
                                let msg = `â’â•â•â•â•â•â¬ *_SPAM BLOCK_* â­â•â•â•â•â•â’\n\n*number* : ${m.sender.replace(/[^0-9]/g,'')}\n*time* : ${ttime}\n*date* : ${tdate}\n*reason* : ${m.type}`;
                                return await conn.sendMessage(conn.user.id, {
                                    text: msg
                                }, {
                                    quoted: m
                                });
                            }
                            if (m.client.body.length > 500) {
                                addQuickMsgd(m.from);
                            }
                        }
                        conn.ws.on('CB:call', async (json) => {
                            if (json.content[0].tag == 'offer') {
                                const tdate = new Date().toLocaleDateString("EN", {
                                    weekday: "long",
                                    year: "numeric",
                                    month: "long",
                                    day: "numeric",
                                });
                                const ttime = new Date().toLocaleString("LK", {
                                    timeZone: TIME_ZONE
                                }).split(" ")[1];
                                callfrom = json.content[0].attrs['call-creator'];
                                const call_id = json.content[0].attrs['call-id'];
                                if (CALL_BLOCK == "true") {
                                    await conn.rejectCall(call_id, callfrom).catch(e => m.send(e));
                                    await sleep(10000);
                                    await conn.updateBlockStatus(callfrom, "block");
                                    let msg = `â’â•â•â•â•â•â¬ *_CALL BLOCK_* â­â•â•â•â•â•â’\n\n*number* : ${callfrom.replace(/[^0-9]/g,'')}\n*time* : ${ttime}\n*date* : ${tdate}`;
                                    return await conn.sendMessage(conn.user.id, {
                                        text: msg
                                    });
                                }
                                if (REJECT_CALL == "true") {
                                    await conn.rejectCall(call_id, callfrom).catch(e => m.send(e));
                                    let msg = `â’â•â•â•â•â•â¬ *_REJECTED CALL_* â­â•â•â•â•â•â’\n\n*number* : ${callfrom.replace(/[^0-9]/g,'')}\n*time* : ${ttime}\n*date* : ${tdate}`;
                                    await sleep(5000);
                                    return await conn.sendMessage(conn.user.id, {
                                        text: msg
                                    });
                                }
                            }
                        });
                        if (PM_BLOCK == "true") {
                            await conn.updateBlockStatus(m.from, "block")
                            const tdate = new Date().toLocaleDateString("EN", {
                                weekday: "long",
                                year: "numeric",
                                month: "long",
                                day: "numeric",
                            });
                            const ttime = new Date().toLocaleString("LK", {
                                timeZone: TIME_ZONE
                            }).split(" ")[1];
                            let msg = `â’â•â•â•â•â•â¬ *_PM BLOCK_* â­â•â•â•â•â•â’\n\n*number* : ${m.sender.replace(/[^0-9]/g,'')}\n*time* : ${ttime}\n*date* : ${tdate}\n*reason* : ${m.type}`;
                            return await conn.sendMessage(conn.user.id, {
                                text: msg
                            }, {
                                quoted: m
                            });
                        }
                        if (BADWORD_BLOCK == "true" && badWordDetect(m.client.body.toLowerCase())) {
                            await conn.updateBlockStatus(m.from, "block")
                            const tdate = new Date().toLocaleDateString("EN", {
                                weekday: "long",
                                year: "numeric",
                                month: "long",
                                day: "numeric",
                            });
                            const ttime = new Date().toLocaleString("LK", {
                                timeZone: TIME_ZONE
                            }).split(" ")[1];
                            let msg = `â’â•â•â•â•â¬ *_BADWORD BLOCK_* â­â•â•â•â•â’\n\n*number* : ${m.sender.replace(/[^0-9]/g,'')}\n*time* : ${ttime}\n*date* : ${tdate}\n*reason* : ${m.client.body}`;
                            return await conn.sendMessage(conn.user.id, {
                                text: msg
                            }, {
                                quoted: m
                            });
                        }
                    }
                    let togcmds = await getTog();
                    let handler = PREFIX == 'false' ? false : PREFIX.trim()
                    let noncmd = handler == false ? false : true;
                    if (handler != false && (handler.startsWith('[') && handler.endsWith(']'))) {
                        let handl = handler.replace('[', '').replace(']', '');
                        handl.split('').map(h => {
                            if (m.client.body.startsWith(h)) {
                                m.client.body = m.client.body.replace(h, '').trim()
                                noncmd = false;
                                handler = h;
                            } else if (h == " ") {
                                m.client.body = m.client.body.trim()
                                noncmd = false;
                                handler = h;
                            }
                        })
                    } else if (handler != false && m.client.body.startsWith(handler)) {
                        m.client.body = m.client.body.replace(handler, '').trim()
                        noncmd = false
                    }
                    if (m.isInrl) noncmd = false;
                    let MOD = WORKTYPE.toLowerCase() == 'public' ? 'public' : 'private';
                    if (m.msg && m.msg.fileSha256 && m.type === "stickerMessage") {
                        const cmds = await getCmdV2(m.msg.fileSha256.join(""));
                        if (cmds) {
                            m.client.body = cmds.dataValues.cmd;
                            noncmd = false;
                        }
                    }
                    let resWithText = false,
                        resWithCmd = false;
                    if (m.quoted && m.quoted.fromMe && m.quoted.text && m.client.body && !isNaN(m.client.body)) {
                        let textformat = m.quoted.text.split('\n');
                        if (textformat[0]) {
                            textformat.map((s) => {
                                if (s.includes('```') && s.split('```').length == 3 && s.match(".")) {
                                    const num = s.split('.')[0].replace(/[^0-9]/g, '')
                                    if (num && (num == m.client.body)) {
                                        resWithCmd += s.split('```')[1];
                                    }
                                }
                            });
                            if (m.quoted.text.includes('*_') && m.quoted.text.includes('_*')) {
                                resWithText += " " + m.quoted.text.split('*_')[1].split('_*')[0]
                            }
                        }
                    }
                    if ((resWithCmd != false) && (resWithText != false)) {
                        m.client.body = resWithCmd.replace(false, "") + resWithText.replace(false, "");
                        noncmd = false;
                        m.isBot = false;
                        resWithCmd = false;
                        resWithText = false;
                    }
                    if (ALLWAYS_ONLINE == "true") {
                        await conn.sendPresenceUpdate("available", m.from);
                    } else {
                        await conn.sendPresenceUpdate("unavailable", m.from);
                    }
                    let isReact = false;
                    commands.map(async (command) => {
                        if (em_ed == "active") em_ed = false;
                        if (MOD == 'private' && !m.client.isCreator) {
                            if (command.fromMe != 'public' && !m.isInrl) {
                                em_ed = "active";
                            }
                        }
                        togcmds.map((l) => {
                            if (m.client.body.toLowerCase().startsWith(l)) {
                                em_ed = "active"
                            }
                        });
                        if (!command.pattern && !command.on) em_ed = "active";
                        if (m.isBot && !command.allowBot) em_ed = "active";
                        if (!em_ed) {
                            if (command.pattern) {
                                EventCmd = command.pattern.replace(/[^a-zA-Z0-9-+]/g, '')
                                if (m.client.body.toLowerCase().startsWith(EventCmd) && (command.DismissPrefix || !noncmd)) {
                                    m.client.command = handler + EventCmd
                                    m.client.text = m.client.body.slice(EventCmd.length).trim();
                                    if (m.client.text == 'help' || m.client.text == 'use' || m.client.text == 'usage' || m.client.text == 'work') {
                                        if (command.usage == "undefined" || command.usage == "null" || command.usage == "false" || !command.usage) {
                                            return await m.send('sorry dear! command usage not found!!')
                                        } else return await m.send(command.usage)
                                    }
                                    if (command.fromMe == true && !m.client.isCreator) {
                                        return;
                                    }
                                    if (command.onlyGroup == true && !m.isGroup) {
                                        return await m.send('_this plugin only work in group_')
                                    }
                                    if (command.onlyPm == true && m.isGroup) {
                                        return await m.send('_this plugin only work in personel chat_')
                                    }
                                    if (command.media == "text" && !m.client.displayText) {
                                        return await m.send('this plugin only response when data as text');
                                    } else if (command.media == "sticker" && !/webp/.test(m.client.mime)) {
                                        return await m.send('this plugin only response when data as sticker');
                                    } else if (command.media == "image" && !/image/.test(m.client.mime)) {
                                        return await m.send('this plugin only response when data as image');
                                    } else if (command.media == "video" && !/video/.test(m.client.mime)) {
                                        return await m.send('this plugin only response when data as video');
                                    } else if (command.media == "audio" && !/audio/.test(m.client.mime)) {
                                        return await m.send('this plugin only response when data as audio');
                                    }
                                    if (SPAM_BLOCK == "true" && !m.isGroup && !m.client.isCreator) {
                                        if (!isWarned(m.jid)) {
                                            giveWarn(m.jid);
                                            await m.send('*Listen! The owner has permission to block spammers, so you will be blocked if spamming is detected. You must give a 5 second pause after each request to avoid blocking*');
                                        }
                                        if (UserSparmed(m.jid)) {
                                            const tdate = new Date().toLocaleDateString("EN", {
                                                weekday: "long",
                                                year: "numeric",
                                                month: "long",
                                                day: "numeric",
                                            });
                                            const ttime = new Date().toLocaleString("LK", {
                                                timeZone: TIME_ZONE
                                            }).split(" ")[1];
                                            await conn.updateBlockStatus(m.jid, "block");
                                            let msg = `â’â•â•â•â•â•â¬ *_SPAM BLOCK_* â­â•â•â•â•â•â’\n\n*number* : ${m.sender.replace(/[^0-9]/g,'')}\n*time* : ${ttime}\n*date* : ${tdate}\n*reason* : ${m.type}`;
                                            return await conn.sendMessage(conn.user.id, {
                                                text: msg
                                            }, {
                                                quoted: m
                                            });
                                        }
                                        SpamAdd(m.jid);
                                    }
                                    if (ANTI_SPAM == "true" && isFiltered(m.from) && !m.client.isCreator) return;
                                    if (ANTI_SPAM == "true") addFilter(m.from);
                                    if (READ_COMMANDS == 'true') {
                                        await conn.readMessages([chatUpdate.messages[0].key])
                                    }
                                    await command.function(m, m.client.text, m.client.command, store).catch((e) => console.log(e));
                                    await conn.sendPresenceUpdate(BOT_PRESENCE, m.from);
                                    if (REACT == 'true') {
                                        isReact = true;
                                        await sleep(100)
                                        await conn.sendMessage(m.from, {
                                            react: {
                                                text: command.react || "ğŸ™ˆ",
                                                key: m.key
                                            }
                                        });
                                    } else if (REACT_CMD == "true") {
                                        isReact = true;
                                        await sleep(100)
                                        await conn.sendMessage(m.from, {
                                            react: {
                                                text: command.react || "ğŸ‘‹ğŸ¿",
                                                key: m.key
                                            }
                                        });
                                    }
                                }
                            }
                            if (command.on === "all" && m) {
                                if (command.fromMe == true && !m.client.isCreator) return;
                                if (command.onlyGroup == true && !m.isGroup) return;
                                if (command.onlyPm == true && m.isGroup) return;
                                command.function(m, m.client.text, m.client.command, chatUpdate, store);
                            } else if (command.on === "text" && m.client.displayText) {
                                if (command.fromMe == true && !m.client.isCreator) return;
                                if (command.onlyGroup == true && !m.isGroup) return;
                                if (command.onlyPm == true && m.isGroup) return;
                                command.function(m, m.client.text, m.client.command, chatUpdate);
                            } else if (command.on === "sticker" && m.type === "stickerMessage") {
                                if (command.fromMe == true && !m.client.isCreator) return;
                                if (command.onlyGroup == true && !m.isGroup) return;
                                if (command.onlyPm == true && m.isGroup) return;
                                command.function(m, m.client.text, m.client.command, chatUpdate);
                            } else if (command.on === "image" && m.type === "imageMessage") {
                                if (command.fromMe == true && !m.client.isCreator) return;
                                if (command.onlyGroup == true && !m.isGroup) return;
                                if (command.onlyPm == true && m.isGroup) return;
                                command.function(m, m.client.text, m.client.command, chatUpdate);
                            } else if (command.on === "video" && m.type === "videoMessage") {
                                if (command.fromMe == true && !m.client.isCreator) return;
                                if (command.onlyGroup == true && !m.isGroup) return;
                                if (command.onlyPm == true && m.isGroup) return;
                                command.function(m, m.client.text, m.client.command, chatUpdate);
                            } else if (command.on === "audio" && m.type === "audioMessage") {
                                if (command.fromMe == true && !m.client.isCreator) return;
                                if (command.onlyGroup == true && !m.isGroup) return;
                                if (command.onlyPm == true && m.isGroup) return;
                                command.function(m, m.client.text, m.client.command, chatUpdate);
                            }
                        }
                    });
                    // some externel function
                    try {
                        if (READ_CHAT == "true") {
                            conn.readMessages([m.key])
                        }
                        if (m.message) {
                            console.log("[ MESSAGE ]"),
                                console.log(new Date()),
                                console.log(m.client.displayText || m.type) + "\n" + console.log("=> From"),
                                console.log(m.client.pushName),
                                console.log(m.sender) + "\n" + console.log("=> In"),
                                console.log(m.isGroup ? m.client.pushName : "Private Chat", m.from)
                        }
                    } catch (err) {
                        console.log(err);
                    }
                    let isRunned = false;
                    if (isRunned == false) {
                        if (AUTO_BIO && AUTO_BIO != 'false') {
                            setInterval(async () => {
                                pstime = new Date().toLocaleDateString("EN", {
                                    weekday: "long",
                                    year: "numeric",
                                    month: "long",
                                    day: "numeric",
                                });
                                psnewt = new Date().toLocaleString("LK", {
                                    timeZone: TIME_ZONE
                                }).split(" ")[1];
                                const biography = AUTO_BIO.replace('&time', psnewt).replace('&date', pstime);
                                await conn.updateProfileStatus(biography);
                            }, 1000 * 60);
                        };
                        setInterval(async () => {
                            let currentTime = new Date().toLocaleString("LK", {
                                timeZone: TIME_ZONE,
                                hour12: false,
                            }).split(" ")[1];
                            currentTime = currentTime.split(':');
                            currentTime = currentTime[0] + ':' + currentTime[1];
                            const mute = await getMute();
                            const unmute = await getUnMute();
                            mute.map(async({status,time,jid})=>{
                                console.log(currentTime,time)
                                if(status && time && currentTime == time) {
                                    await conn.groupSettingUpdate(jid, "announcement");
                                }
                            })
                            unmute.map(async({status,time,jid})=>{
                                if(status && time && currentTime == time) {
                                    await conn.groupSettingUpdate(jid, "not_announcement");
                                }
                            })
                        }, 1000 * 55);
                    }
                    isRunned = true;
                    // all link ban
                    if (m.isGroup) {
                        const text = (m.client.displayText || 'ÃŸÃŸÃŸÃŸÃŸ').toLowerCase();
                        const actionLink = await getAntiLink(m.jid);
                        const actionWord = await getAntiWords(m.jid);
                        const resone = "The law in the group was not accepted";
                        if (actionLink.status && !m.client.isCreator) {
                            if (text.includes('http')) {
                                if (!await isBotAdmin(m)) return;
                                if (await isAdmin(m)) return;
                                const {
                                    action
                                } = actionLink;
                                if (action == "warn") {
                                    await conn.sendMessage(m.from, {
                                        delete: m.key
                                    })
                                    const res = await setWarn(m.sender, m.jid, resone)
                                    let remains = WARNCOUND - res.count;
                                    let warnmsg = `ââ”€â”€â”€â”€â”€[ á´¡á´€Ê€É´ÉªÉ´É¢ ]â”€â”€â”€â”€â”€â
â”‚ User :- @${res.user.replace(/[^0-9]/g,'')}
ââ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â
â”â”€â”€â”€â”€â”€â”€â”€ INFO â”€â”€â”€â”€â”€â”€â”€â
â”‚ Reason :- ${res.reason}
â”‚ Count :- ${res.count}
â”‚ Remaining :- ${remains}
â”—â€¢â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â`
                                    await m.client.sendMessage(m.jid, {
                                        text: warnmsg,
                                        mentions: [res.user]
                                    })
                                    if (remains <= 0) {
                                        await ResetWarn(m.sender, m.jid)
                                        await conn.groupParticipantsUpdate(m.jid, [m.sender], "remove");
                                    }
                                } else if (action == "kick") {
                                    await conn.sendMessage(m.from, {
                                        delete: m.key
                                    })
                                    await conn.groupParticipantsUpdate(m.jid, [m.sender], "remove");
                                } else {
                                    await conn.sendMessage(m.from, {
                                        delete: m.key
                                    })
                                    await m.reply("_Links Not allowed in this group_")
                                }
                            }
                        }
                        if (actionWord.status && !m.client.isCreator) {
                            if (!await isBotAdmin(m)) return;
                            if (await isAdmin(m)) return;
                            const notAllowed = actionWord.word ? actionWord.word.split(',') || [actionWord.word] : [];
                            notAllowed.map(async (word) => {
                                if (text.includes(word)) {
                                    if (actionWord.action == "warn") {
                                        await conn.sendMessage(m.from, {
                                            delete: m.key
                                        })
                                        const res = await setWarn(m.sender, m.jid, resone)
                                        let remains = WARNCOUND - res.count;
                                        let warnmsg = `ââ”€â”€â”€â”€â”€[ á´¡á´€Ê€É´ÉªÉ´É¢ ]â”€â”€â”€â”€â”€â
â”‚ User :- @${res.user.replace(/[^0-9]/g,'')}
ââ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â
â”â”€â”€â”€â”€â”€â”€â”€ INFO â”€â”€â”€â”€â”€â”€â”€â
â”‚ Reason :- ${res.reason}
â”‚ Count :- ${res.count}
â”‚ Remaining :- ${remains}
â”—â€¢â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â`
                                        await m.client.sendMessage(m.jid, {
                                            text: warnmsg,
                                            mentions: [res.user]
                                        })
                                        if (remains <= 0) {
                                            await ResetWarn(m.sender, m.jid)
                                            await conn.groupParticipantsUpdate(m.jid, [m.sender], "remove");
                                        }
                                    } else if (actionWord.action == "kick") {
                                        await conn.sendMessage(m.from, {
                                            delete: m.key
                                        })
                                        await conn.groupParticipantsUpdate(m.jid, [m.sender], "remove");
                                    } else {
                                        await conn.sendMessage(m.from, {
                                            delete: m.key
                                        })
                                    }
                                }
                            })
                        }
                    }
                    //end
                    //automatic reaction
                    if (!em_ed) {
                        if (REACT == 'true' && m && !isReact) {
                            if (m.client.body.match(/\p{EPres}|\p{ExtPict}/gu)) {
                                await sleep(100)
                                await conn.sendMessage(m.from, {
                                    react: {
                                        text: m.client.body.match(/\p{EPres}|\p{ExtPict}/gu)[0],
                                        key: m.key
                                    }
                                });
                            } else {
                                let reactArray = ['ğŸ’˜', 'ğŸ’', 'ğŸ’–', 'ğŸ’—', 'ğŸ’“', 'ğŸ’', 'ğŸ’•', 'ğŸ’Ÿ', 'â£ï¸', 'ğŸ’”', 'â¤ï¸', 'ğŸ§¡', 'ğŸ’›', 'ğŸ’š', 'ğŸ’™', 'ğŸ’œ', 'ğŸ¤', 'ğŸ–¤', 'ğŸ¤', 'â¤ï¸â€', 'ğŸ”¥', 'â¤ï¸â€', 'ğŸ©¹', 'ğŸ’¯', 'â™¨ï¸', 'ğŸ’¢', 'ğŸ’¬', 'ğŸ‘ï¸â€ğŸ—¨ï¸', 'ğŸ—¨ï¸', 'ğŸ—¯ï¸', 'ğŸ’­', 'ğŸ’¤', 'ğŸŒ', 'â™ ï¸', 'â™¥ï¸', 'â™¦ï¸', 'â™£ï¸', 'ğŸƒ', 'ğŸ€„ï¸', 'ğŸ´', 'ğŸ­ï¸', 'ğŸ”‡', 'ğŸ”ˆï¸', 'ğŸ”‰', 'ğŸ”Š', 'ğŸ””', 'ğŸ”•', 'ğŸ¼', 'ğŸµ', 'ğŸ¶', 'ğŸ’¹', 'ğŸ§', 'ğŸš®', 'ğŸš°', 'â™¿ï¸', 'ğŸš¹ï¸', 'ğŸšºï¸', 'ğŸš»', 'ğŸš¼ï¸', 'ğŸš¾', 'ğŸ›‚', 'ğŸ›ƒ', 'ğŸ›„', 'ğŸ›…', 'âš ï¸', 'ğŸš¸', 'â›”ï¸', 'ğŸš«', 'ğŸš³', 'ğŸš­ï¸', 'ğŸš¯', 'ğŸš±', 'ğŸš·', 'ğŸ“µ', 'ğŸ”', 'â˜¢ï¸', 'â˜£ï¸', 'â¬†ï¸', 'â†—ï¸', 'â¡ï¸', 'â†˜ï¸', 'â¬‡ï¸', 'â†™ï¸', 'â¬…ï¸', 'â†–ï¸', 'â†•ï¸', 'â†”ï¸', 'â†©ï¸', 'â†ªï¸', 'â¤´ï¸', 'â¤µï¸', 'ğŸ”ƒ', 'ğŸ”„', 'ğŸ”™', 'ğŸ”š', 'ğŸ”›', 'ğŸ”œ', 'ğŸ”', 'ğŸ›', 'âš›ï¸', 'ğŸ•‰ï¸', 'âœ¡ï¸', 'â˜¸ï¸', 'â˜¯ï¸', 'âœï¸', 'â˜¦ï¸', 'â˜ªï¸', 'â˜®ï¸', 'ğŸ•', 'ğŸ”¯', 'â™ˆï¸', 'â™‰ï¸', 'â™Šï¸', 'â™‹ï¸', 'â™Œï¸', 'â™ï¸', 'â™ï¸', 'â™ï¸', 'â™ï¸', 'â™‘ï¸', 'â™’ï¸', 'â™“ï¸', 'â›', 'ğŸ”€', 'ğŸ”', 'ğŸ”‚', 'â–¶ï¸', 'â©ï¸', 'â­ï¸', 'â¯ï¸', 'â—€ï¸', 'âªï¸', 'â®ï¸', 'ğŸ”¼', 'â«', 'ğŸ”½', 'â¬', 'â¸ï¸', 'â¹ï¸', 'âºï¸', 'âï¸', 'ğŸ¦', 'ğŸ”…', 'ğŸ”†', 'ğŸ“¶', 'ğŸ“³', 'ğŸ“´', 'â™€ï¸', 'â™‚ï¸', 'âš§', 'âœ–ï¸', 'â•', 'â–', 'â—', 'â™¾ï¸', 'â€¼ï¸', 'â‰ï¸', 'â“ï¸', 'â”', 'â•', 'â—ï¸', 'ã€°ï¸', 'ğŸ’±', 'ğŸ’²', 'âš•ï¸', 'â™»ï¸', 'âšœï¸', 'ğŸ”±', 'ğŸ“›', 'ğŸ”°', 'â­•ï¸', 'âœ…', 'â˜‘ï¸', 'âœ”ï¸', 'âŒ', 'â', 'â°', 'â¿', 'ã€½ï¸', 'âœ³ï¸', 'âœ´ï¸', 'â‡ï¸', 'Â©ï¸', 'Â®ï¸', 'â„¢ï¸', '#ï¸âƒ£', '*ï¸âƒ£', '0ï¸âƒ£', '1ï¸âƒ£', '2ï¸âƒ£', '3ï¸âƒ£', '4ï¸âƒ£', '5ï¸âƒ£', '6ï¸âƒ£', '7ï¸âƒ£', '8ï¸âƒ£', '9ï¸âƒ£', 'ğŸ”Ÿ', 'ğŸ” ', 'ğŸ”¡', 'ğŸ”¢', 'ğŸ”£', 'ğŸ”¤', 'ğŸ…°ï¸', 'ğŸ†', 'ğŸ…±ï¸', 'ğŸ†‘', 'ğŸ†’', 'ğŸ†“', 'â„¹ï¸', 'ğŸ†”', 'â“‚ï¸', 'ğŸ†•', 'ğŸ†–', 'ğŸ…¾ï¸', 'ğŸ†—', 'ğŸ…¿ï¸', 'ğŸ†˜', 'ğŸ†™', 'ğŸ†š', 'ğŸˆ', 'ğŸˆ‚ï¸', 'ğŸˆ·ï¸', 'ğŸˆ¶', 'ğŸˆ¯ï¸', 'ğŸ‰', 'ğŸˆ¹', 'ğŸˆšï¸', 'ğŸˆ²', 'ğŸ‰‘', 'ğŸˆ¸', 'ğŸˆ´', 'ğŸˆ³', 'ãŠ—ï¸', 'ãŠ™ï¸', 'ğŸˆº', 'ğŸˆµ', 'ğŸ”´', 'ğŸŸ ', 'ğŸŸ¡', 'ğŸŸ¢', 'ğŸ”µ', 'ğŸŸ£', 'ğŸŸ¤', 'âš«ï¸', 'âšªï¸', 'ğŸŸ¥', 'ğŸŸ§', 'ğŸŸ¨', 'ğŸŸ©', 'ğŸŸ¦', 'ğŸŸª', 'ğŸŸ«', 'â¬›ï¸', 'â¬œï¸', 'â—¼ï¸', 'â—»ï¸', 'â—¾ï¸', 'â—½ï¸', 'â–ªï¸', 'â–«ï¸', 'ğŸ”¶', 'ğŸ”·', 'ğŸ”¸', 'ğŸ”¹', 'ğŸ”º', 'ğŸ”»', 'ğŸ’ ', 'ğŸ”˜', 'ğŸ”³', 'ğŸ”²', 'ğŸ•›ï¸', 'ğŸ•§ï¸', 'ğŸ•ï¸', 'ğŸ•œï¸', 'ğŸ•‘ï¸', 'ğŸ•ï¸', 'ğŸ•’ï¸', 'ğŸ•ï¸', 'ğŸ•“ï¸', 'ğŸ•Ÿï¸', 'ğŸ•”ï¸', 'ğŸ• ï¸', 'ğŸ••ï¸', 'ğŸ•¡ï¸', 'ğŸ•–ï¸', 'ğŸ•¢ï¸', 'ğŸ•—ï¸', 'ğŸ•£ï¸', 'ğŸ•˜ï¸', 'ğŸ•¤ï¸', 'ğŸ•™ï¸', 'ğŸ•¥ï¸', 'ğŸ•šï¸', 'ğŸ•¦ï¸', '*ï¸', '#ï¸', '0ï¸', '1ï¸', '2ï¸', '3ï¸', '4ï¸', '5ï¸', '6ï¸', '7ï¸', '8ï¸', '9ï¸', 'ğŸ›ï¸', 'ğŸ§³', 'âŒ›ï¸', 'â³ï¸', 'âŒšï¸', 'â°', 'â±ï¸', 'â²ï¸', 'ğŸ•°ï¸', 'ğŸŒ¡ï¸', 'ğŸ—ºï¸', 'ğŸ§­', 'ğŸƒ', 'ğŸ„', 'ğŸ§¨', 'ğŸˆ', 'ğŸ‰', 'ğŸŠ', 'ğŸ', 'ğŸ', 'ğŸ', 'ğŸ€', 'ğŸ', 'ğŸ—ï¸', 'ğŸŸï¸', 'ğŸ«', 'ğŸ”®', 'ğŸ§¿', 'ğŸ®ï¸', 'ğŸ•¹ï¸', 'ğŸ°', 'ğŸ²', 'â™Ÿï¸', 'ğŸ§©', 'ğŸ§¸', 'ğŸ–¼ï¸', 'ğŸ¨', 'ğŸ§µ', 'ğŸ§¶', 'ğŸ‘“ï¸', 'ğŸ•¶ï¸', 'ğŸ¥½', 'ğŸ¥¼', 'ğŸ¦º', 'ğŸ‘”', 'ğŸ‘•', 'ğŸ‘–', 'ğŸ§£', 'ğŸ§¤', 'ğŸ§¥', 'ğŸ§¦', 'ğŸ‘—', 'ğŸ‘˜', 'ğŸ¥»', 'ğŸ©±', 'ğŸ©²', 'ğŸ©³', 'ğŸ‘™', 'ğŸ‘š', 'ğŸ‘›', 'ğŸ‘œ', 'ğŸ‘', 'ğŸ›ï¸', 'ğŸ’', 'ğŸ‘', 'ğŸ‘Ÿ', 'ğŸ¥¾', 'ğŸ¥¿', 'ğŸ‘ ', 'ğŸ‘¡', 'ğŸ©°', 'ğŸ‘¢', 'ğŸ‘‘', 'ğŸ‘’', 'ğŸ©', 'ğŸ“ï¸', 'ğŸ§¢', 'â›‘ï¸', 'ğŸ“¿', 'ğŸ’„', 'ğŸ’', 'ğŸ’', 'ğŸ“¢', 'ğŸ“£', 'ğŸ“¯', 'ğŸ™ï¸', 'ğŸšï¸', 'ğŸ›ï¸', 'ğŸ¤', 'ğŸ§ï¸', 'ğŸ“»ï¸', 'ğŸ·', 'ğŸ¸', 'ğŸ¹', 'ğŸº', 'ğŸ»', 'ğŸª•', 'ğŸ¥', 'ğŸ“±', 'ğŸ“²', 'â˜ï¸', 'ğŸ“', 'ğŸ“Ÿï¸', 'ğŸ“ ', 'ğŸ”‹', 'ğŸ”Œ', 'ğŸ’»ï¸', 'ğŸ–¥ï¸', 'ğŸ–¨ï¸', 'âŒ¨ï¸', 'ğŸ–±ï¸', 'ğŸ–²ï¸', 'ğŸ’½', 'ğŸ’¾', 'ğŸ’¿ï¸', 'ğŸ“€', 'ğŸ§®', 'ğŸ¥', 'ğŸï¸', 'ğŸ“½ï¸', 'ğŸ¬ï¸', 'ğŸ“ºï¸', 'ğŸ“·ï¸', 'ğŸ“¸', 'ğŸ“¹ï¸', 'ğŸ“¼', 'ğŸ”ï¸', 'ğŸ”', 'ğŸ•¯ï¸', 'ğŸ’¡', 'ğŸ”¦', 'ğŸ®', 'ğŸª”', 'ğŸ“”', 'ğŸ“•', 'ğŸ“–', 'ğŸ“—', 'ğŸ“˜', 'ğŸ“™', 'ğŸ“šï¸', 'ğŸ““', 'ğŸ“’', 'ğŸ“ƒ', 'ğŸ“œ', 'ğŸ“„', 'ğŸ“°', 'ğŸ—ï¸', 'ğŸ“‘', 'ğŸ”–', 'ğŸ·ï¸', 'ğŸ’°ï¸', 'ğŸ’´', 'ğŸ’µ', 'ğŸ’¶', 'ğŸ’·', 'ğŸ’¸', 'ğŸ’³ï¸', 'ğŸ§¾', 'âœ‰ï¸', 'ğŸ’Œ', 'ğŸ“§', 'ğŸ§§', 'ğŸ“¨', 'ğŸ“©', 'ğŸ“¤ï¸', 'ğŸ“¥ï¸', 'ğŸ“¦ï¸', 'ğŸ“«ï¸', 'ğŸ“ªï¸', 'ğŸ“¬ï¸', 'ğŸ“­ï¸', 'ğŸ“®', 'ğŸ—³ï¸', 'âœï¸', 'âœ’ï¸', 'ğŸ–‹ï¸', 'ğŸ–Šï¸', 'ğŸ–Œï¸', 'ğŸ–ï¸', 'ğŸ“', 'ğŸ’¼', 'ğŸ“', 'ğŸ“‚', 'ğŸ—‚ï¸', 'ğŸ“…', 'ğŸ“†', 'ğŸ—’ï¸', 'ğŸ—“ï¸', 'ğŸ“‡', 'ğŸ“ˆ', 'ğŸ“‰', 'ğŸ“Š', 'ğŸ“‹ï¸', 'ğŸ“Œ', 'ğŸ“', 'ğŸ“', 'ğŸ–‡ï¸', 'ğŸ“', 'ğŸ“', 'âœ‚ï¸', 'ğŸ—ƒï¸', 'ğŸ—„ï¸', 'ğŸ—‘ï¸', 'ğŸ”’ï¸', 'ğŸ”“ï¸', 'ğŸ”', 'ğŸ”', 'ğŸ”‘', 'ğŸ—ï¸', 'ğŸ”¨', 'ğŸª“', 'â›ï¸', 'âš’ï¸', 'ğŸ› ï¸', 'ğŸ—¡ï¸', 'âš”ï¸', 'ğŸ’£ï¸', 'ğŸ¹', 'ğŸ›¡ï¸', 'ğŸ”§', 'ğŸ”©', 'âš™ï¸', 'ğŸ—œï¸', 'âš–ï¸', 'ğŸ¦¯', 'ğŸ”—', 'â›“ï¸', 'ğŸ§°', 'ğŸ§²', 'âš—ï¸', 'ğŸ§ª', 'ğŸ§«', 'ğŸ§¬', 'ğŸ”¬', 'ğŸ”­', 'ğŸ“¡', 'ğŸ’‰', 'ğŸ©¸', 'ğŸ’Š', 'ğŸ©¹', 'ğŸ©º', 'ğŸšª', 'ğŸ›ï¸', 'ğŸ›‹ï¸', 'ğŸª‘', 'ğŸš½', 'ğŸš¿', 'ğŸ›', 'ğŸª’', 'ğŸ§´', 'ğŸ§·', 'ğŸ§¹', 'ğŸ§º', 'ğŸ§»', 'ğŸ§¼', 'ğŸ§½', 'ğŸ§¯', 'ğŸ›’', 'ğŸš¬', 'âš°ï¸', 'âš±ï¸', 'ğŸº', 'ğŸ•³ï¸', 'ğŸ”ï¸', 'â›°ï¸', 'ğŸŒ‹', 'ğŸ—»', 'ğŸ•ï¸', 'ğŸ–ï¸', 'ğŸœï¸', 'ğŸï¸', 'ğŸŸï¸', 'ğŸ›ï¸', 'ğŸ—ï¸', 'ğŸ§±', 'ğŸ˜ï¸', 'ğŸšï¸', 'ğŸ ï¸', 'ğŸ¡', 'ğŸ¢', 'ğŸ£', 'ğŸ¤', 'ğŸ¥', 'ğŸ¦', 'ğŸ¨', 'ğŸ©', 'ğŸª', 'ğŸ«', 'ğŸ¬', 'ğŸ­ï¸', 'ğŸ¯', 'ğŸ°', 'ğŸ’’', 'ğŸ—¼', 'ğŸ—½', 'â›ªï¸', 'ğŸ•Œ', 'ğŸ›•', 'ğŸ•', 'â›©ï¸', 'ğŸ•‹', 'â›²ï¸', 'â›ºï¸', 'ğŸŒ', 'ğŸŒƒ', 'ğŸ™ï¸', 'ğŸŒ„', 'ğŸŒ…', 'ğŸŒ†', 'ğŸŒ‡', 'ğŸŒ‰', 'ğŸ—¾', 'ğŸï¸', 'ğŸ ', 'ğŸ¡', 'ğŸ¢', 'ğŸ’ˆ', 'ğŸª', 'ğŸš‚', 'ğŸšƒ', 'ğŸš„', 'ğŸš…', 'ğŸš†', 'ğŸš‡ï¸', 'ğŸšˆ', 'ğŸš‰', 'ğŸšŠ', 'ğŸš', 'ğŸš', 'ğŸš‹', 'ğŸšŒ', 'ğŸšï¸', 'ğŸš', 'ğŸš', 'ğŸš‘ï¸', 'ğŸš’', 'ğŸš“', 'ğŸš”ï¸', 'ğŸš•', 'ğŸš–', 'ğŸš—', 'ğŸš˜ï¸', 'ğŸš™', 'ğŸšš', 'ğŸš›', 'ğŸšœ', 'ğŸï¸', 'ğŸï¸', 'ğŸ›µ', 'ğŸ¦½', 'ğŸ¦¼', 'ğŸ›º', 'ğŸš²ï¸', 'ğŸ›´', 'ğŸ›¹', 'ğŸš', 'ğŸ›£ï¸', 'ğŸ›¤ï¸', 'ğŸ›¢ï¸', 'â›½ï¸', 'ğŸš¨', 'ğŸš¥', 'ğŸš¦', 'ğŸ›‘', 'ğŸš§', 'âš“ï¸', 'â›µï¸', 'ğŸ›¶', 'ğŸš¤', 'ğŸ›³ï¸', 'â›´ï¸', 'ğŸ›¥ï¸', 'ğŸš¢', 'âœˆï¸', 'ğŸ›©ï¸', 'ğŸ›«', 'ğŸ›¬', 'ğŸª‚', 'ğŸ’º', 'ğŸš', 'ğŸšŸ', 'ğŸš ', 'ğŸš¡', 'ğŸ›°ï¸', 'ğŸš€', 'ğŸ›¸', 'ğŸ†', 'ğŸ‡', 'ğŸ‘', 'ğŸ—¿', 'âš½ï¸', 'âš¾ï¸', 'ğŸ¥', 'ğŸ€', 'ğŸ', 'ğŸˆ', 'ğŸ‰', 'ğŸ¾', 'ğŸ¥', 'ğŸ³', 'ğŸ', 'ğŸ‘', 'ğŸ’', 'ğŸ¥', 'ğŸ“', 'ğŸ¸', 'ğŸ¥Š', 'ğŸ¥‹', 'ğŸ¥…', 'â›³ï¸', 'â›¸ï¸', 'ğŸ£', 'ğŸ¤¿', 'ğŸ½', 'ğŸ¿', 'ğŸ›·', 'ğŸ¥Œ', 'ğŸ¯', 'ğŸª€', 'ğŸª', 'ğŸ±', 'ğŸ–ï¸', 'ğŸ†ï¸', 'ğŸ…', 'ğŸ¥‡', 'ğŸ¥ˆ', 'ğŸ¥‰', 'ğŸ‡', 'ğŸˆ', 'ğŸ‰', 'ğŸŠ', 'ğŸ‹', 'ğŸŒ', 'ğŸ', 'ğŸ¥­', 'ğŸ', 'ğŸ', 'ğŸ', 'ğŸ‘', 'ğŸ’', 'ğŸ“', 'ğŸ¥', 'ğŸ…', 'ğŸ¥¥', 'ğŸ¥‘', 'ğŸ†', 'ğŸ¥”', 'ğŸ¥•', 'ğŸŒ½', 'ğŸŒ¶ï¸', 'ğŸ¥’', 'ğŸ¥¬', 'ğŸ¥¦', 'ğŸ§„', 'ğŸ§…', 'ğŸ„', 'ğŸ¥œ', 'ğŸŒ°', 'ğŸ', 'ğŸ¥', 'ğŸ¥–', 'ğŸ¥¨', 'ğŸ¥¯', 'ğŸ¥', 'ğŸ§‡', 'ğŸ§€', 'ğŸ–', 'ğŸ—', 'ğŸ¥©', 'ğŸ¥“', 'ğŸ”', 'ğŸŸ', 'ğŸ•', 'ğŸŒ­', 'ğŸ¥ª', 'ğŸŒ®', 'ğŸŒ¯', 'ğŸ¥™', 'ğŸ§†', 'ğŸ¥š', 'ğŸ³', 'ğŸ¥˜', 'ğŸ²', 'ğŸ¥£', 'ğŸ¥—', 'ğŸ¿', 'ğŸ§ˆ', 'ğŸ§‚', 'ğŸ¥«', 'ğŸ±', 'ğŸ˜', 'ğŸ™', 'ğŸš', 'ğŸ›', 'ğŸœ', 'ğŸ', 'ğŸ ', 'ğŸ¢', 'ğŸ£', 'ğŸ¤', 'ğŸ¥', 'ğŸ¥®', 'ğŸ¡', 'ğŸ¥Ÿ', 'ğŸ¥ ', 'ğŸ¥¡', 'ğŸ¦', 'ğŸ§', 'ğŸ¨', 'ğŸ©', 'ğŸª', 'ğŸ‚', 'ğŸ°', 'ğŸ§', 'ğŸ¥§', 'ğŸ«', 'ğŸ¬', 'ğŸ­', 'ğŸ®', 'ğŸ¯', 'ğŸ¼', 'ğŸ¥›', 'â˜•ï¸', 'ğŸµ', 'ğŸ¶', 'ğŸ¾', 'ğŸ·', 'ğŸ¸ï¸', 'ğŸ¹', 'ğŸº', 'ğŸ»', 'ğŸ¥‚', 'ğŸ¥ƒ', 'ğŸ¥¤', 'ğŸ§ƒ', 'ğŸ§‰', 'ğŸ§Š', 'ğŸ¥¢', 'ğŸ½ï¸', 'ğŸ´', 'ğŸ¥„', 'ğŸ”ª', 'ğŸµ', 'ğŸ’', 'ğŸ¦', 'ğŸ¦§', 'ğŸ¶', 'ğŸ•ï¸', 'ğŸ¦®', 'ğŸ•â€', 'ğŸ¦º', 'ğŸ©', 'ğŸº', 'ğŸ¦Š', 'ğŸ¦', 'ğŸ±', 'ğŸˆï¸', 'ğŸˆâ€', 'ğŸ¦', 'ğŸ¯', 'ğŸ…', 'ğŸ†', 'ğŸ´', 'ğŸ', 'ğŸ¦„', 'ğŸ¦“', 'ğŸ¦Œ', 'ğŸ®', 'ğŸ‚', 'ğŸƒ', 'ğŸ„', 'ğŸ·', 'ğŸ–', 'ğŸ—', 'ğŸ½', 'ğŸ', 'ğŸ‘', 'ğŸ', 'ğŸª', 'ğŸ«', 'ğŸ¦™', 'ğŸ¦’', 'ğŸ˜', 'ğŸ¦', 'ğŸ¦›', 'ğŸ­', 'ğŸ', 'ğŸ€', 'ğŸ¹', 'ğŸ°', 'ğŸ‡', 'ğŸ¿ï¸', 'ğŸ¦”', 'ğŸ¦‡', 'ğŸ»', 'ğŸ»â€', 'â„ï¸', 'ğŸ¨', 'ğŸ¼', 'ğŸ¦¥', 'ğŸ¦¦', 'ğŸ¦¨', 'ğŸ¦˜', 'ğŸ¦¡', 'ğŸ¾', 'ğŸ¦ƒ', 'ğŸ”', 'ğŸ“', 'ğŸ£', 'ğŸ¤', 'ğŸ¥', 'ğŸ¦ï¸', 'ğŸ§', 'ğŸ•Šï¸', 'ğŸ¦…', 'ğŸ¦†', 'ğŸ¦¢', 'ğŸ¦‰', 'ğŸ¦©', 'ğŸ¦š', 'ğŸ¦œ', 'ğŸ¸', 'ğŸŠ', 'ğŸ¢', 'ğŸ¦', 'ğŸ', 'ğŸ²', 'ğŸ‰', 'ğŸ¦•', 'ğŸ¦–', 'ğŸ³', 'ğŸ‹', 'ğŸ¬', 'ğŸŸï¸', 'ğŸ ', 'ğŸ¡', 'ğŸ¦ˆ', 'ğŸ™', 'ğŸ¦‘', 'ğŸ¦€', 'ğŸ¦', 'ğŸ¦', 'ğŸ¦ª', 'ğŸš', 'ğŸŒ', 'ğŸ¦‹', 'ğŸ›', 'ğŸœ', 'ğŸ', 'ğŸ', 'ğŸ¦—', 'ğŸ•·ï¸', 'ğŸ•¸ï¸', 'ğŸ¦‚', 'ğŸ¦Ÿ', 'ğŸ¦ ', 'ğŸ’', 'ğŸŒ¸', 'ğŸ’®', 'ğŸµï¸', 'ğŸŒ¹', 'ğŸ¥€', 'ğŸŒº', 'ğŸŒ»', 'ğŸŒ¼', 'ğŸŒ·', 'ğŸŒ±', 'ğŸŒ²', 'ğŸŒ³', 'ğŸŒ´', 'ğŸŒµ', 'ğŸ‹', 'ğŸ', 'ğŸŒ¾', 'ğŸŒ¿', 'â˜˜ï¸', 'ğŸ€', 'ğŸ', 'ğŸ‚', 'ğŸƒ', 'ğŸŒï¸', 'ğŸŒï¸', 'ğŸŒï¸', 'ğŸŒ‘', 'ğŸŒ’', 'ğŸŒ“', 'ğŸŒ”', 'ğŸŒ•ï¸', 'ğŸŒ–', 'ğŸŒ—', 'ğŸŒ˜', 'ğŸŒ™', 'ğŸŒš', 'ğŸŒ›', 'ğŸŒœï¸', 'â˜€ï¸', 'ğŸŒ', 'ğŸŒ', 'ğŸª', 'ğŸ’«', 'â­ï¸', 'ğŸŒŸ', 'âœ¨', 'ğŸŒ ', 'ğŸŒŒ', 'â˜ï¸', 'â›…ï¸', 'â›ˆï¸', 'ğŸŒ¤ï¸', 'ğŸŒ¥ï¸', 'ğŸŒ¦ï¸', 'ğŸŒ§ï¸', 'ğŸŒ¨ï¸', 'ğŸŒ©ï¸', 'ğŸŒªï¸', 'ğŸŒ«ï¸', 'ğŸŒ¬ï¸', 'ğŸŒ€', 'ğŸŒˆ', 'ğŸŒ‚', 'â˜‚ï¸', 'â˜”ï¸', 'â›±ï¸', 'âš¡ï¸', 'â„ï¸', 'â˜ƒï¸', 'â›„ï¸', 'â˜„ï¸', 'ğŸ”¥', 'ğŸ’§', 'ğŸŒŠ', 'ğŸ’¥', 'ğŸ’¦', 'ğŸ’¨', 'ğŸ˜€', 'ğŸ˜ƒ', 'ğŸ˜„', 'ğŸ˜', 'ğŸ˜†', 'ğŸ˜…', 'ğŸ¤£', 'ğŸ˜‚', 'ğŸ™‚', 'ğŸ™ƒ', 'ğŸ˜‰', 'ğŸ˜Š', 'ğŸ˜‡', 'ğŸ¥°', 'ğŸ˜', 'ğŸ¤©', 'ğŸ˜˜', 'ğŸ˜—', 'â˜ºï¸', 'ğŸ˜š', 'ğŸ˜™', 'ğŸ˜‹', 'ğŸ˜›', 'ğŸ˜œ', 'ğŸ¤ª', 'ğŸ˜', 'ğŸ¤‘', 'ğŸ¤—', 'ğŸ¤­', 'ğŸ¤«', 'ğŸ¤”', 'ğŸ¤', 'ğŸ¤¨', 'ğŸ˜ï¸', 'ğŸ˜‘', 'ğŸ˜¶', 'ğŸ˜', 'ğŸ˜’', 'ğŸ™„', 'ğŸ˜¬', 'ğŸ¤¥', 'ğŸ˜Œ', 'ğŸ˜”', 'ğŸ˜ª', 'ğŸ˜®â€', 'ğŸ’¨', 'ğŸ¤¤', 'ğŸ˜´', 'ğŸ˜·', 'ğŸ¤’', 'ğŸ¤•', 'ğŸ¤¢', 'ğŸ¤®', 'ğŸ¤§', 'ğŸ¥µ', 'ğŸ¥¶', 'ğŸ˜¶â€', 'ğŸŒ«ï¸', 'ğŸ¥´', 'ğŸ˜µâ€', 'ğŸ’«', 'ğŸ˜µ', 'ğŸ¤¯', 'ğŸ¤ ', 'ğŸ¥³', 'ğŸ˜', 'ğŸ¤“', 'ğŸ§', 'ğŸ˜•', 'ğŸ˜Ÿ', 'ğŸ™', 'â˜¹ï¸', 'ğŸ˜®', 'ğŸ˜¯', 'ğŸ˜²', 'ğŸ˜³', 'ğŸ¥º', 'ğŸ˜¦', 'ğŸ˜§', 'ğŸ˜¨', 'ğŸ˜°', 'ğŸ˜¥', 'ğŸ˜¢', 'ğŸ˜­', 'ğŸ˜±', 'ğŸ˜–', 'ğŸ˜£', 'ğŸ˜', 'ğŸ˜“', 'ğŸ˜©', 'ğŸ˜«', 'ğŸ¥±', 'ğŸ˜¤', 'ğŸ˜¡', 'ğŸ˜ ', 'ğŸ¤¬', 'ğŸ˜ˆ', 'ğŸ‘¿', 'ğŸ’€', 'â˜ ï¸', 'ğŸ’©', 'ğŸ¤¡', 'ğŸ‘¹', 'ğŸ‘º', 'ğŸ‘»', 'ğŸ‘½ï¸', 'ğŸ‘¾', 'ğŸ¤–', 'ğŸ˜º', 'ğŸ˜¸', 'ğŸ˜¹', 'ğŸ˜»', 'ğŸ˜¼', 'ğŸ˜½', 'ğŸ™€', 'ğŸ˜¿', 'ğŸ˜¾', 'ğŸ™ˆ', 'ğŸ™‰', 'ğŸ™Š', 'ğŸ‘‹', 'ğŸ¤š', 'ğŸ–ï¸', 'âœ‹', 'ğŸ––', 'ğŸ‘Œ', 'ğŸ¤', 'âœŒï¸', 'ğŸ¤', 'ğŸ¤Ÿ', 'ğŸ¤˜', 'ğŸ¤™', 'ğŸ‘ˆï¸', 'ğŸ‘‰ï¸', 'ğŸ‘†ï¸', 'ğŸ–•', 'ğŸ‘‡ï¸', 'â˜ï¸', 'ğŸ‘ï¸', 'ğŸ‘ï¸', 'âœŠ', 'ğŸ‘Š', 'ğŸ¤›', 'ğŸ¤œ', 'ğŸ‘', 'ğŸ™Œ', 'ğŸ‘', 'ğŸ¤²', 'ğŸ¤', 'ğŸ™', 'âœï¸', 'ğŸ’…', 'ğŸ¤³', 'ğŸ’ª', 'ğŸ¦¾', 'ğŸ¦¿', 'ğŸ¦µ', 'ğŸ¦¶', 'ğŸ‘‚ï¸', 'ğŸ¦»', 'ğŸ‘ƒ', 'ğŸ§ ', 'ğŸ¦·', 'ğŸ¦´', 'ğŸ‘€', 'ğŸ‘ï¸', 'ğŸ‘…', 'ğŸ‘„', 'ğŸ’‹', 'ğŸ‘¶', 'ğŸ§’', 'ğŸ‘¦', 'ğŸ‘§', 'ğŸ§‘', 'ğŸ‘¨', 'ğŸ‘©', 'ğŸ§”', 'ğŸ§”â€â™€ï¸', 'ğŸ§”â€â™‚ï¸', 'ğŸ§‘', 'ğŸ‘¨â€', 'ğŸ¦°', 'ğŸ‘©â€', 'ğŸ¦°', 'ğŸ§‘', 'ğŸ‘¨â€', 'ğŸ¦±', 'ğŸ‘©â€', 'ğŸ¦±', 'ğŸ§‘', 'ğŸ‘¨â€', 'ğŸ¦³', 'ğŸ‘©â€', 'ğŸ¦³', 'ğŸ§‘', 'ğŸ‘¨â€', 'ğŸ¦²', 'ğŸ‘©â€', 'ğŸ¦²', 'ğŸ‘±', 'ğŸ‘±â€â™‚ï¸', 'ğŸ‘±â€â™€ï¸', 'ğŸ§“', 'ğŸ‘´', 'ğŸ‘µ', 'ğŸ™', 'ğŸ™â€â™‚ï¸', 'ğŸ™â€â™€ï¸', 'ğŸ™', 'ğŸ™â€â™‚ï¸', 'ğŸ™â€â™€ï¸', 'ğŸ™…', 'ğŸ™…â€â™‚ï¸', 'ğŸ™…â€â™€ï¸', 'ğŸ™†', 'ğŸ™†â€â™‚ï¸', 'ğŸ™†â€â™€ï¸', 'ğŸ’', 'ğŸ’â€â™‚ï¸', 'ğŸ’â€â™€ï¸', 'ğŸ™‹', 'ğŸ™‹â€â™‚ï¸', 'ğŸ™‹â€â™€ï¸', 'ğŸ§', 'ğŸ§â€â™‚ï¸', 'ğŸ§â€â™€ï¸', 'ğŸ™‡', 'ğŸ™‡â€â™‚ï¸', 'ğŸ™‡â€â™€ï¸', 'ğŸ¤¦', 'ğŸ¤¦â€â™‚ï¸', 'ğŸ¤¦â€â™€ï¸', 'ğŸ¤·', 'ğŸ¤·â€â™‚ï¸', 'ğŸ¤·â€â™€ï¸', 'ğŸ§‘â€âš•ï¸', 'ğŸ‘¨â€âš•ï¸', 'ğŸ‘©â€âš•ï¸', 'ğŸ§‘â€ğŸ“', 'ğŸ‘¨â€ğŸ“', 'ğŸ‘©â€ğŸ“', 'ğŸ§‘â€ğŸ«', 'ğŸ‘¨â€ğŸ«', 'ğŸ‘©â€ğŸ«', 'ğŸ§‘â€âš–ï¸', 'ğŸ‘¨â€âš–ï¸', 'ğŸ‘©â€âš–ï¸', 'ğŸ§‘â€ğŸŒ¾', 'ğŸ‘¨â€ğŸŒ¾', 'ğŸ‘©â€ğŸŒ¾', 'ğŸ§‘â€ğŸ³', 'ğŸ‘¨â€ğŸ³', 'ğŸ‘©â€ğŸ³', 'ğŸ§‘â€ğŸ”§', 'ğŸ‘¨â€ğŸ”§', 'ğŸ‘©â€ğŸ”§', 'ğŸ§‘â€ğŸ­', 'ğŸ‘¨â€ğŸ­', 'ğŸ‘©â€ğŸ­', 'ğŸ§‘â€ğŸ’¼', 'ğŸ‘¨â€ğŸ’¼', 'ğŸ‘©â€ğŸ’¼', 'ğŸ§‘â€ğŸ”¬', 'ğŸ‘¨â€ğŸ”¬', 'ğŸ‘©â€ğŸ”¬', 'ğŸ§‘â€ğŸ’»', 'ğŸ‘¨â€ğŸ’»', 'ğŸ‘©â€ğŸ’»', 'ğŸ§‘â€ğŸ¤', 'ğŸ‘¨â€ğŸ¤', 'ğŸ‘©â€ğŸ¤', 'ğŸ§‘â€ğŸ¨', 'ğŸ‘¨â€ğŸ¨', 'ğŸ‘©â€ğŸ¨', 'ğŸ§‘â€âœˆï¸', 'ğŸ‘¨â€âœˆï¸', 'ğŸ‘©â€âœˆï¸', 'ğŸ§‘â€ğŸš€', 'ğŸ‘¨â€ğŸš€', 'ğŸ‘©â€ğŸš€', 'ğŸ§‘â€ğŸš’', 'ğŸ‘¨â€ğŸš’', 'ğŸ‘©â€ğŸš’', 'ğŸ‘®', 'ğŸ‘®â€â™‚ï¸', 'ğŸ‘®â€â™€ï¸', 'ğŸ•µï¸', 'ğŸ•µï¸â€â™‚ï¸', 'ğŸ•µï¸â€â™€ï¸', 'ğŸ’‚', 'ğŸ’‚â€â™‚ï¸', 'ğŸ’‚â€â™€ï¸', 'ğŸ‘·', 'ğŸ‘·â€â™‚ï¸', 'ğŸ‘·â€â™€ï¸', 'ğŸ¤´', 'ğŸ‘¸', 'ğŸ‘³', 'ğŸ‘³â€â™‚ï¸', 'ğŸ‘³â€â™€ï¸', 'ğŸ‘²', 'ğŸ§•', 'ğŸ¤µ', 'ğŸ¤µâ€â™‚ï¸', 'ğŸ¤µâ€â™€ï¸', 'ğŸ‘°', 'ğŸ‘°â€â™‚ï¸', 'ğŸ‘°â€â™€ï¸', 'ğŸ¤°', 'ğŸ¤±', 'ğŸ‘©â€', 'ğŸ¼', 'ğŸ‘¨â€', 'ğŸ¼', 'ğŸ§‘â€', 'ğŸ¼', 'ğŸ‘¼', 'ğŸ…', 'ğŸ¤¶', 'ğŸ§‘â€', 'ğŸ„', 'ğŸ¦¸', 'ğŸ¦¸â€â™‚ï¸', 'ğŸ¦¸â€â™€ï¸', 'ğŸ¦¹', 'ğŸ¦¹â€â™‚ï¸', 'ğŸ¦¹â€â™€ï¸', 'ğŸ§™', 'ğŸ§™â€â™‚ï¸', 'ğŸ§™â€â™€ï¸', 'ğŸ§š', 'ğŸ§šâ€â™‚ï¸', 'ğŸ§šâ€â™€ï¸', 'ğŸ§›', 'ğŸ§›â€â™‚ï¸', 'ğŸ§›â€â™€ï¸', 'ğŸ§œ', 'ğŸ§œâ€â™‚ï¸', 'ğŸ§œâ€â™€ï¸', 'ğŸ§', 'ğŸ§â€â™‚ï¸', 'ğŸ§â€â™€ï¸', 'ğŸ§', 'ğŸ§â€â™‚ï¸', 'ğŸ§â€â™€ï¸', 'ğŸ§Ÿ', 'ğŸ§Ÿâ€â™‚ï¸', 'ğŸ§Ÿâ€â™€ï¸', 'ğŸ’†', 'ğŸ’†â€â™‚ï¸', 'ğŸ’†â€â™€ï¸', 'ğŸ’‡', 'ğŸ’‡â€â™‚ï¸', 'ğŸ’‡â€â™€ï¸', 'ğŸš¶', 'ğŸš¶â€â™‚ï¸', 'ğŸš¶â€â™€ï¸', 'ğŸ§', 'ğŸ§â€â™‚ï¸', 'ğŸ§â€â™€ï¸', 'ğŸ§', 'ğŸ§â€â™‚ï¸', 'ğŸ§â€â™€ï¸', 'ğŸ§‘â€', 'ğŸ¦¯', 'ğŸ‘¨â€', 'ğŸ¦¯', 'ğŸ‘©â€', 'ğŸ¦¯', 'ğŸ§‘â€', 'ğŸ¦¼', 'ğŸ‘¨â€', 'ğŸ¦¼', 'ğŸ‘©â€', 'ğŸ¦¼', 'ğŸ§‘â€', 'ğŸ¦½', 'ğŸ‘¨â€', 'ğŸ¦½', 'ğŸ‘©â€', 'ğŸ¦½', 'ğŸƒ', 'ğŸƒâ€â™‚ï¸', 'ğŸƒâ€â™€ï¸', 'ğŸ’ƒ', 'ğŸ•º', 'ğŸ•´ï¸', 'ğŸ‘¯', 'ğŸ‘¯â€â™‚ï¸', 'ğŸ‘¯â€â™€ï¸', 'ğŸ§–', 'ğŸ§–â€â™‚ï¸', 'ğŸ§–â€â™€ï¸', 'ğŸ§—', 'ğŸ§—â€â™‚ï¸', 'ğŸ§—â€â™€ï¸', 'ğŸ¤º', 'ğŸ‡', 'â›·ï¸', 'ğŸ‚ï¸', 'ğŸŒï¸', 'ğŸŒï¸â€â™‚ï¸', 'ğŸŒï¸â€â™€ï¸', 'ğŸ„ï¸', 'ğŸ„â€â™‚ï¸', 'ğŸ„â€â™€ï¸', 'ğŸš£', 'ğŸš£â€â™‚ï¸', 'ğŸš£â€â™€ï¸', 'ğŸŠï¸', 'ğŸŠâ€â™‚ï¸', 'ğŸŠâ€â™€ï¸', 'â›¹ï¸', 'â›¹ï¸â€â™‚ï¸', 'â›¹ï¸â€â™€ï¸', 'ğŸ‹ï¸', 'ğŸ‹ï¸â€â™‚ï¸', 'ğŸ‹ï¸â€â™€ï¸', 'ğŸš´', 'ğŸš´â€â™‚ï¸', 'ğŸš´â€â™€ï¸', 'ğŸšµ', 'ğŸšµâ€â™‚ï¸', 'ğŸšµâ€â™€ï¸', 'ğŸ¤¸', 'ğŸ¤¸â€â™‚ï¸', 'ğŸ¤¸â€â™€ï¸', 'ğŸ¤¼', 'ğŸ¤¼â€â™‚ï¸', 'ğŸ¤¼â€â™€ï¸', 'ğŸ¤½', 'ğŸ¤½â€â™‚ï¸', 'ğŸ¤½â€â™€ï¸', 'ğŸ¤¾', 'ğŸ¤¾â€â™‚ï¸', 'ğŸ¤¾â€â™€ï¸', 'ğŸ¤¹', 'ğŸ¤¹â€â™‚ï¸', 'ğŸ¤¹â€â™€ï¸', 'ğŸ§˜', 'ğŸ§˜â€â™‚ï¸', 'ğŸ§˜â€â™€ï¸', 'ğŸ›€', 'ğŸ›Œ', 'ğŸ§‘â€', 'ğŸ¤â€', 'ğŸ§‘', 'ğŸ‘­', 'ğŸ‘«', 'ğŸ‘¬', 'ğŸ’', 'ğŸ‘©â€â¤ï¸â€ğŸ’‹â€ğŸ‘¨', 'ğŸ‘¨â€â¤ï¸â€ğŸ’‹â€ğŸ‘¨', 'ğŸ‘©â€â¤ï¸â€ğŸ’‹â€ğŸ‘©', 'ğŸ’‘', 'ğŸ‘©â€â¤ï¸â€ğŸ‘¨', 'ğŸ‘¨â€â¤ï¸â€ğŸ‘¨', 'ğŸ‘©â€â¤ï¸â€ğŸ‘©', 'ğŸ‘ªï¸', 'ğŸ‘¨â€ğŸ‘©â€ğŸ‘¦', 'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§', 'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦', 'ğŸ‘¨â€ğŸ‘©â€ğŸ‘¦â€ğŸ‘¦', 'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘§', 'ğŸ‘¨â€ğŸ‘¨â€ğŸ‘¦', 'ğŸ‘¨â€ğŸ‘¨â€ğŸ‘§', 'ğŸ‘¨â€ğŸ‘¨â€ğŸ‘§â€ğŸ‘¦', 'ğŸ‘¨â€ğŸ‘¨â€ğŸ‘¦â€ğŸ‘¦', 'ğŸ‘¨â€ğŸ‘¨â€ğŸ‘§â€ğŸ‘§', 'ğŸ‘©â€ğŸ‘©â€ğŸ‘¦', 'ğŸ‘©â€ğŸ‘©â€ğŸ‘§', 'ğŸ‘©â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦', 'ğŸ‘©â€ğŸ‘©â€ğŸ‘¦â€ğŸ‘¦', 'ğŸ‘©â€ğŸ‘©â€ğŸ‘§â€ğŸ‘§', 'ğŸ‘¨â€ğŸ‘¦', 'ğŸ‘¨â€ğŸ‘¦â€ğŸ‘¦', 'ğŸ‘¨â€ğŸ‘§', 'ğŸ‘¨â€ğŸ‘§â€ğŸ‘¦', 'ğŸ‘¨â€ğŸ‘§â€ğŸ‘§', 'ğŸ‘©â€ğŸ‘¦', 'ğŸ‘©â€ğŸ‘¦â€ğŸ‘¦', 'ğŸ‘©â€ğŸ‘§', 'ğŸ‘©â€ğŸ‘§â€ğŸ‘¦', 'ğŸ‘©â€ğŸ‘§â€ğŸ‘§', 'ğŸ—£ï¸', 'ğŸ‘¤', 'ğŸ‘¥', 'ğŸ‘£'];
                                let getType = reactArray[Math.floor(Math.random() * reactArray.length)];
                                await sleep(100)
                                await conn.sendMessage(m.from, {
                                    react: {
                                        text: getType,
                                        key: m.key
                                    }
                                });
                            }
                        } else if (REACT != 'true' && m && REACT_EMOJI == "true" && !isReact) {
                            if (m.client.body.match(/\p{EPres}|\p{ExtPict}/gu)) {
                                await conn.sendMessage(m.from, {
                                    react: {
                                        text: m.client.body.match(/\p{EPres}|\p{ExtPict}/gu)[0],
                                        key: m.key
                                    }
                                });
                            }
                        }
                    }
                });
            } else if (connection === "close") {
                console.log("Connection closed with bot. Please put New Session ID again.");
                await sleep(3000)
                WhatsBotConnect();
            }
        });
        setInterval(async () => {
            await removeFile("");
            await removeFile("media");
        }, 1000 * 30);
    } catch (err) {
        console.log(err)
    }
} // function closing
app.get("/", (req, res) => {
    res.send("Hello Inrl started\nversion: " + require("./package.json").version);
});
app.listen(port, () => console.log(`Inrl Server listening on port http://localhost:${port}`));
setTimeout(() => {
    WhatsBotConnect();
}, 3000);
