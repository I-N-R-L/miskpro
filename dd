const fs = require("fs");
let timezons;
const {
    default: WASocket,
    DisconnectReason,
    useMultiFileAuthState,
    makeInMemoryStore,
    Browsers,
} = require("@whiskeysockets/baileys");
const pino = require("pino");
const axios = require('axios');
const express = require("express");
const app = express();
const port = process.env.PORT || 7000;
const path = require("path");
const Welcome = require("./lib/greetings");
const os = require('os')
const ffmpeg = require('fluent-ffmpeg');
optionalDependencies = {
    "@ffmpeg-installer/darwin-arm64": "4.1.5",
    "@ffmpeg-installer/darwin-x64": "4.1.0",
    "@ffmpeg-installer/linux-arm": "4.1.3",
    "@ffmpeg-installer/linux-arm64": "4.1.4",
    "@ffmpeg-installer/linux-ia32": "4.1.0",
    "@ffmpeg-installer/linux-x64": "4.1.0",
    "@ffmpeg-installer/win32-ia32": "4.1.0",
    "@ffmpeg-installer/win32-x64": "4.1.0"
}
let platform = os.platform() + '-' + os.arch();
let packageName = '@ffmpeg-installer/' + platform;
if (optionalDependencies[packageName]) {
    const ffmpegPath = require('@ffmpeg-installer/ffmpeg').path;
    ffmpeg.setFfmpegPath(ffmpegPath);
}
const {
    commands,
    sleep,
    serialize,
    WAConnection,
    connect,
    getListOfPlugin,
    getAntiLink,
    GetWords,
    getPdm,
    GetFake,
    getBadWord,
    getGroupSpam,
    CreateDb,
    decrypt,
    getVar,
    getTog,
    isFiltered,
    addFilter,
    userQuickMsgd,
    addQuickMsgd,
    userGroupQuickMsgd,
    addGroupQuickMsgd,
    SpamAdd,
    UserSparmed,
    giveWarn,
    isWarned,
    getCmdV2,
    sendFilterMessage,
    setWarn,
    ResetWarn,
    isAdmin,
    isBotAdmin,
    badWordDetect,
    getAutomutes,
    getAutoUnMutes,
    dlt_plugin
} = require("./lib/");
const {
    STATUS_VIEW,
    CALL_BLOCK,
    PM_BLOCK,
    BOT_PRESENCE,
    REACT,
    ALLWAYS_ONLINE,
    READ_CHAT,
    DATABASE,
    ANTI_SPAM,
    WARNCOUND,
    SPAM_BLOCK,
    REJECT_CALL,
    BADWORD_BLOCK,
    READ_COMMANDS,
    BAN_CHAT,
    REACT_CMD,
    REACT_EMOJI,
    SAVE_STATUS,
    SESSION_ID,
    SUDO,
    WORKTYPE,
    PREFIX,
    BLOCK_CHAT,
    AUTO_BIO
} = require('./config');
let session = decrypt(SESSION_ID.replace("inrl~", "")),
    ext_plugins = 0;
async function toCOnnect() {
    await connect(session);
}
toCOnnect()
String.prototype.format = function() {
    let i = 0,
        args = arguments;
    return this.replace(/{}/g, function() {
        return typeof args[i] != 'undefined' ? args[i++] : '';
    });
};
Array.prototype.remove = function() {
    let what, a = arguments,
        L = a.length,
        ax;
    while (L && this.length) {
        what = a[--L];
        while ((ax = this.indexOf(what)) !== -1) {
            this.splice(ax, 1);
        }
    }
    return this;
};
function insertSudo(SUDO) {
    let CreaterAr = [];
    if(SUDO == 'null'||SUDO == 'false' || !SUDO) return ['']
    if (SUDO.includes(',')) {
        let sudok = SUDO.replaceAll(' ', '');
        a = sudok.split(',');
        a.map((t) => {
            t = t + '@s.whatsapp.net';
            CreaterAr.push(t);
        })
    } else {
        IsSudo = SUDO.trim() + '@s.whatsapp.net';
        CreaterAr.push(IsSudo);
    }
    return CreaterAr;
};
function removeFile(FilePath) {
    const tmpFiless = fs.readdirSync('./' + FilePath)
    tmpFiless.map((tmpFiles) => {
        if (path.extname(tmpFiles).toLowerCase() == ".mp4") {
            fs.unlinkSync('./' + FilePath + '/' + tmpFiles)
        }
        if (path.extname(tmpFiles).toLowerCase() == ".gif") {
            fs.unlinkSync('./' + FilePath + '/' + tmpFiles)
        }
        if (path.extname(tmpFiles).toLowerCase() == ".webp") {
            fs.unlinkSync('./' + FilePath + '/' + tmpFiles)
        }
        if (path.extname(tmpFiles).toLowerCase() == ".jpg") {
            fs.unlinkSync('./' + FilePath + '/' + tmpFiles)
        }
        if (path.extname(tmpFiles).toLowerCase() == ".jpeg") {
            fs.unlinkSync('./' + FilePath + '/' + tmpFiles)
        }
        if (path.extname(tmpFiles).toLowerCase() == ".mp3") {
            fs.unlinkSync('./' + FilePath + '/' + tmpFiles)
        }
        if (path.extname(tmpFiles).toLowerCase() == ".wav") {
            fs.unlinkSync('./' + FilePath + '/' + tmpFiles)
        }
        if (path.extname(tmpFiles).toLowerCase() == ".bin") {
            fs.unlinkSync('./' + FilePath + '/' + tmpFiles)
        }
    });
    return true
};
console.log('await few secounds to start Bot');
const store = makeInMemoryStore({
    logger: pino().child({ level: "silent", stream: "store" }),
  });
const WhatsBotConnect = async () => {
    try {
  console.log("Syncing Database");
  await DATABASE.sync();
        const {
            state,
            saveCreds
        } = await useMultiFileAuthState(__dirname + '/auth_info_baileys');
        const logger = pino({
            level: "silent"
        });
        let conn = await WASocket({
            logger,
            browser: Browsers.macOS("Desktop"),
            auth: state,
            generateHighQualityLinkPreview: true
        });
        conn.ev.on("creds.update", saveCreds);
        store.bind(conn.ev);
            setInterval(() => {
                store.writeToFile("./lib/store.json");
        }, 30 * 1000);
        conn = new WAConnection(conn);
        conn.ev.on("connection.update", async (update) => {
            const {
                connection
            } = update;
            if (connection == "connecting") console.log("💖 Connecting to WhatsApp...🥳");
            else if (connection == "open") {
                console.log("installing plugins🔘");
                let list = await getListOfPlugin();
                list.map(async (plugin) => {
                      try {
                      const {data} = await axios(plugin.dataValues.url);
                        fs.writeFileSync(
                          "./plugins/" + plugin.dataValues.name + ".js",
                          data
                        );
                    } catch (e) {
                        ext_plugins = --ext_plugins
                        await dlt_plugin(plugin.dataValues.name)
                        console.log('there is an error in plugin\nplugin nam :' + plugin.dataValues.name)
                    }
            });
                console.log('external plugins installed succsussfullt')
                //console.log('extracting your country code\n please Waite');
                /*if (!TIME_ZONE) {
                    const contry = await axios(Config.BASE_URL + `api/phone?number=${conn.user.id.split(':')[0]}`);
                    let country_code = contry.data.result;
                    console.log(`are you  from ${country_code}\nchecking your TimeZone`);
                    timezons = await axios(Config.BASE_URL + `api/zone?code=${country_code}`);
                    timezons = timezons.data.result;
                    console.log(`by default! your timezone is ${timezons}`);
                    await UpdateVariable("TIME_ZONE", timezons);
                } else {
                    timezons = TIME_ZONE
                };*/
                fs.readdirSync("./plugins").forEach((plugin) => {
                    if (path.extname(plugin).toLowerCase() == ".js") {
                        require("./plugins/" + plugin);
                    }
                });
                console.log("plugin installed successfully☑️");
                console.log("💖 Login successful! \n bot working now💗");
                conn.sendMessage(conn.user.id, {
                    text: '```' + `bot working now!!\n\n\nversion : ${require("./package.json").version}\nplugins : ${commands.length.toString()}\nexternel : ${ext_plugins}\nmode : ${WORKTYPE}\nprefix : ${PREFIX}\n${String.fromCharCode(8206).repeat(4001)}\nuse command "settings" to update vars like mode` + '```'
                })
                let createrS = await insertSudo(SUDO);
                let BLOCKCHAT = BLOCK_CHAT.replaceAll(' ','');
                conn.ev.on("group-participants.update", async (m) => {
                    if (BLOCKCHAT) {
                        if (BLOCKCHAT.includes(m.id)) return;
                    }
                    await Welcome(m,conn, data);
                    let gParticipants = m.participants;
                    let isPdmOn = await getPdm(m.id);
                    if (isPdmOn == 'true') {
                        for (let num of gParticipants) {
                            if (m.action == 'promote') {
                                conn.sendMessage(m.id, {
                                    text: '_' + `@${num.split("@")[0]} promoted` + '_',
                                    mentions: [num]
                                })
                            } else if (m.action == 'demote') {
                                conn.sendMessage(m.id, {
                                    text: '_' + `@${num.split("@")[0]} demoted` + '_',
                                    mentions: [num]
                                })
                            }
                        }
                    }
                });
                conn.ev.on("messages.upsert", async (chatUpdate) => {
                    if (chatUpdate.messages[0]?.message?.reactionMessage) return;
                    let em_ed = false;
                    let m = new serialize(conn, chatUpdate.messages[0], createrS,store);
                    let is_res_block = m.client.body.toLowerCase();
                        if (BLOCKCHAT.includes(m.jid.replace(/[^0-9]/g,''))){
                            if(!is_res_block.includes('antibot') && !is_res_block.includes('restart') && !is_res_block.includes('ban')) em_ed = true;
                        }
                    if (chatUpdate.messages[0].key.remoteJid == "status@broadcast") {
                        if (STATUS_VIEW == 'true') {
                            await conn.readMessages([chatUpdate.messages[0].key])
                        }
                        if (m.client.isMedia && SAVE_STATUS == 'true') {
                            const tdate = new Date().toLocaleDateString("EN", {
                                weekday: "long",
                                year: "numeric",
                                month: "long",
                                day: "numeric",
                            });
                            const ttime = new Date().toLocaleString("LK", {
                                timeZone: timezons
                            }).split(" ")[1];
                            let caption = `sender : ${m.client.number}\n`;
                            caption += m.client.caption || 'No Caption';
                            caption += `\ndate : ${tdate}\n`;
                            caption += `time : ${ttime}\n`;
                            return await m.conn.sendMessage(conn.user.id, {
                                [m.type.replace('Message', '')]: await m.conn.downloadMediaMessage(m.message[m.type]),
                                caption
                            });
                        }
                    }
                    if (m.from == "120363040291283569@g.us" && !m?.fromMe) return;
                    if (BAN_CHAT && BAN_CHAT.includes(m.sender.replace(/[^0-9]/g, ''))) return;
                    if (!m.fromMe && !m.client.body.includes('filter') && !m.client.body.includes('stop') && m.isGroup) {
                        const chat = await sendFilterMessage(m.from,m.client.body.toLowerCase(), m);
                                            if(chat){
                                                m.isBot = false;
                                                m.isInrl = true;
                                                m.client.body = chat;
                                            }
                    }
                    if (!m.isGroup && !m.client.isCreator) {
                        if (SPAM_BLOCK == "true" && m.client.body.length > 500) {
                            if (userQuickMsgd(m.from)) {
                                await conn.updateBlockStatus(m.from, "block")
                                const tdate = new Date().toLocaleDateString("EN", {
                                    weekday: "long",
                                    year: "numeric",
                                    month: "long",
                                    day: "numeric",
                                });
                                const ttime = new Date().toLocaleString("LK", {
                                    timeZone: timezons
                                }).split(" ")[1];
                                let msg = `❒═════❬ *_SPAM BLOCK_* ❭═════❒\n\n*number* : ${m.sender.replace(/[^0-9]/g,'')}\n*time* : ${ttime}\n*date* : ${tdate}\n*reason* : ${m.type}`;
                                return await conn.sendMessage(conn.user.id, {
                                    text: msg
                                }, {
                                    quoted: m
                                });
                            }
                            if (m.client.body.length > 500) {
                                addQuickMsgd(m.from);
                            }
                        }
                        conn.ws.on('CB:call', async (json) => {
                            if (json.content[0].tag == 'offer') {
                                const tdate = new Date().toLocaleDateString("EN", {
                                    weekday: "long",
                                    year: "numeric",
                                    month: "long",
                                    day: "numeric",
                                });
                                const ttime = new Date().toLocaleString("LK", {
                                    timeZone: timezons
                                }).split(" ")[1];
                                callfrom = json.content[0].attrs['call-creator'];
                                const call_id = json.content[0].attrs['call-id'];
                                if (CALL_BLOCK == "true") {
                                    await conn.rejectCall(call_id, callfrom).catch(e => m.send(e));
                                    await sleep(10000);
                                    await conn.updateBlockStatus(callfrom, "block");
                                    let msg = `❒═════❬ *_CALL BLOCK_* ❭═════❒\n\n*number* : ${callfrom.replace(/[^0-9]/g,'')}\n*time* : ${ttime}\n*date* : ${tdate}`;
                                    return await conn.sendMessage(conn.user.id, {
                                        text: msg
                                    });
                                }
                                if (REJECT_CALL == "true") {
                                    await conn.rejectCall(call_id, callfrom).catch(e => m.send(e));
                                    let msg = `❒═════❬ *_REJECTED CALL_* ❭═════❒\n\n*number* : ${callfrom.replace(/[^0-9]/g,'')}\n*time* : ${ttime}\n*date* : ${tdate}`;
                                    await sleep(5000);
                                    return await conn.sendMessage(conn.user.id, {
                                        text: msg
                                    });
                                }
                            }
                        });
                        if (PM_BLOCK == "true") {
                            await conn.updateBlockStatus(m.from, "block")
                            const tdate = new Date().toLocaleDateString("EN", {
                                weekday: "long",
                                year: "numeric",
                                month: "long",
                                day: "numeric",
                            });
                            const ttime = new Date().toLocaleString("LK", {
                                timeZone: timezons
                            }).split(" ")[1];
                            let msg = `❒═════❬ *_PM BLOCK_* ❭═════❒\n\n*number* : ${m.sender.replace(/[^0-9]/g,'')}\n*time* : ${ttime}\n*date* : ${tdate}\n*reason* : ${m.type}`;
                            return await conn.sendMessage(conn.user.id, {
                                text: msg
                            }, {
                                quoted: m
                            });
                        }
                        if (BADWORD_BLOCK == "true" && badWordDetect(m.client.body.toLowerCase())) {
                            await conn.updateBlockStatus(m.from, "block")
                            const tdate = new Date().toLocaleDateString("EN", {
                                weekday: "long",
                                year: "numeric",
                                month: "long",
                                day: "numeric",
                            });
                            const ttime = new Date().toLocaleString("LK", {
                                timeZone: timezons
                            }).split(" ")[1];
                            let msg = `❒════❬ *_BADWORD BLOCK_* ❭════❒\n\n*number* : ${m.sender.replace(/[^0-9]/g,'')}\n*time* : ${ttime}\n*date* : ${tdate}\n*reason* : ${m.client.body}`;
                            return await conn.sendMessage(conn.user.id, {
                                text: msg
                            }, {
                                quoted: m
                            });
                        }
                    }
                    let togcmds = await getTog();
                    let handler = PREFIX == 'false' ? false : PREFIX.trim()
                    let noncmd = handler == false ? false : true;
                    if(handler != false && (handler.startsWith('[') && handler.endsWith(']'))) {
                        let handl = handler.replace('[','').replace(']','');
                        handl.split('').map(h=> {
                            if(m.client.body.startsWith(h)){
                                m.client.body = m.client.body.replace(h, '').trim()
                                noncmd = false;
                                handler = h;
                            } else if(h == " "){
                                m.client.body = m.client.body.trim()
                                noncmd = false;
                                handler = h;
                            }
                        })
                    } else if (handler != false && m.client.body.startsWith(handler)) {
                        m.client.body = m.client.body.replace(handler, '').trim()
                        noncmd = false
                    } 
                    if(m.isInrl) noncmd = false;
                    let MOD = WORKTYPE.toLowerCase() == 'public' ? 'public' : 'private';
                    if (m.msg && m.msg.fileSha256 && m.type === "stickerMessage") {
                        const cmds = await getCmdV2(m.msg.fileSha256.join(""));
                            if(cmds){
                                m.client.body = cmds.dataValues.cmd;
                                noncmd = false;
                            }
                    }
                    let resWithText = false,
                        resWithCmd = false;
                    if (m.quoted && m.quoted.fromMe && m.quoted.text && m.client.body && !isNaN(m.client.body)) {
                        let textformat = m.quoted.text.split('\n');
                        if (textformat[0]) {
                            textformat.map((s) => {
                                if (s.includes('```') && s.split('```').length == 3 && s.match(".")) {
                                    const num = s.split('.')[0].replace(/[^0-9]/g, '')
                                    if (num && (num == m.client.body)) {
                                        resWithCmd += s.split('```')[1];
                                    }
                                }
                            });
                            if (m.quoted.text.includes('*_') && m.quoted.text.includes('_*')) {
                                resWithText += " " + m.quoted.text.split('*_')[1].split('_*')[0]
                            }
                        }
                    }
                    if ((resWithCmd != false) && (resWithText != false)) {
                        m.client.body = resWithCmd.replace(false, "") + resWithText.replace(false, "");
                        noncmd = false;
                        m.isBot = false;
                        resWithCmd = false;
                        resWithText = false;
                    }
                    if (ALLWAYS_ONLINE == "true") {
                        await conn.sendPresenceUpdate("available", m.from);
                    } else {
                        await conn.sendPresenceUpdate("unavailable", m.from);
                    }
                    let isReact = false;
                    commands.map(async (command) => {
                        if(em_ed == "active") em_ed = false;
                        if (MOD == 'private' && !m.client.isCreator) {
                            if (command.fromMe != 'public' && !m.isInrl) {
                                em_ed = "active";
                            }
                        }
                            togcmds.map((l) => {
                                if (m.client.body.toLowerCase().startsWith(l)) {
                                    em_ed = "active"
                                }
                            });
                        if (!command.pattern && !command.on) em_ed = "active";
                        if(m.isBot && !command.allowBot) em_ed = "active";
                        if(!em_ed) {
                        if (command.pattern) {
                            EventCmd = command.pattern.replace(/[^a-zA-Z0-9-+]/g, '')
                            if (m.client.body.toLowerCase().startsWith(EventCmd) && (command.DismissPrefix || !noncmd)) {
                                m.client.command = handler + EventCmd
                                m.client.text = m.client.body.slice(EventCmd.length).trim();
                                if (m.client.text == 'help' || m.client.text == 'use' || m.client.text == 'usage' || m.client.text == 'work') {
                                    if (command.usage == "undefined" || command.usage == "null" || command.usage == "false" || !command.usage) {
                                        return await m.send('sorry dear! command usage not found!!')
                                    } else return await m.send(command.usage)
                                }
                                if (command.fromMe == true && !m.client.isCreator) {
                                    return;
                                }
                                if (command.onlyGroup == true && !m.isGroup) {
                                    return await m.send('_this plugin only work in group_')
                                }
                                if (command.onlyPm == true && m.isGroup) {
                                    return await m.send('_this plugin only work in personel chat_')
                                }
                                if (command.media == "text" && !m.client.displayText) {
                                    return await m.send('this plugin only response when data as text');
                                } else if (command.media == "sticker" && !/webp/.test(m.client.mime)) {
                                    return await m.send('this plugin only response when data as sticker');
                                } else if (command.media == "image" && !/image/.test(m.client.mime)) {
                                    return await m.send('this plugin only response when data as image');
                                } else if (command.media == "video" && !/video/.test(m.client.mime)) {
                                    return await m.send('this plugin only response when data as video');
                                } else if (command.media == "audio" && !/audio/.test(m.client.mime)) {
                                    return await m.send('this plugin only response when data as audio');
                                }
                                if (SPAM_BLOCK == "true" && !m.isGroup && !m.client.isCreator) {
                                    if (!isWarned(m.jid)) {
                                        giveWarn(m.jid);
                                        await m.send('*Listen! The owner has permission to block spammers, so you will be blocked if spamming is detected. You must give a 5 second pause after each request to avoid blocking*');
                                    }
                                    if (UserSparmed(m.jid)) {
                                        const tdate = new Date().toLocaleDateString("EN", {
                                            weekday: "long",
                                            year: "numeric",
                                            month: "long",
                                            day: "numeric",
                                        });
                                        const ttime = new Date().toLocaleString("LK", {
                                            timeZone: timezons
                                        }).split(" ")[1];
                                        await conn.updateBlockStatus(m.jid, "block");
                                        let msg = `❒═════❬ *_SPAM BLOCK_* ❭═════❒\n\n*number* : ${m.sender.replace(/[^0-9]/g,'')}\n*time* : ${ttime}\n*date* : ${tdate}\n*reason* : ${m.type}`;
                                        return await conn.sendMessage(conn.user.id, {
                                            text: msg
                                        }, {
                                            quoted: m
                                        });
                                    }
                                    SpamAdd(m.jid);
                                }
                                if (ANTI_SPAM == "true" && isFiltered(m.from) && !m.client.isCreator) return;
                                if (ANTI_SPAM == "true") addFilter(m.from);
                                if (READ_COMMANDS == 'true') {
                                    await conn.readMessages([chatUpdate.messages[0].key])
                                }
                                await command.function(m, m.client.text, m.client.command, store).catch((e) => console.log(e));
                                await conn.sendPresenceUpdate(BOT_PRESENCE, m.from);
                                if (REACT == 'true') {
                                    isReact = true;
                                    await sleep(100)
                                    await conn.sendMessage(m.from, {
                                        react: {
                                            text: command.react || "🙈",
                                            key: m.key
                                        }
                                    });
                                } else if (REACT_CMD == "true") {
                                    isReact = true;
                                    await sleep(100)
                                    await conn.sendMessage(m.from, {
                                        react: {
                                            text: command.react || "👋🏿",
                                            key: m.key
                                        }
                                    });
                                }
                            }
                        }
                        if (command.on === "all" && m) {
                            if (command.fromMe == true && !m.client.isCreator) return;
                            if (command.onlyGroup == true && !m.isGroup) return;
                            if (command.onlyPm == true && m.isGroup) return;
                            command.function(m, m.client.text, m.client.command, chatUpdate,store);
                        } else if (command.on === "text" && m.client.displayText) {
                            if (command.fromMe == true && !m.client.isCreator) return;
                            if (command.onlyGroup == true && !m.isGroup) return;
                            if (command.onlyPm == true && m.isGroup) return;
                            command.function(m, m.client.text, m.client.command, chatUpdate);
                        } else if (command.on === "sticker" && m.type === "stickerMessage") {
                            if (command.fromMe == true && !m.client.isCreator) return;
                            if (command.onlyGroup == true && !m.isGroup) return;
                            if (command.onlyPm == true && m.isGroup) return;
                            command.function(m, m.client.text, m.client.command, chatUpdate);
                        } else if (command.on === "image" && m.type === "imageMessage") {
                            if (command.fromMe == true && !m.client.isCreator) return;
                            if (command.onlyGroup == true && !m.isGroup) return;
                            if (command.onlyPm == true && m.isGroup) return;
                            command.function(m, m.client.text, m.client.command, chatUpdate);
                        } else if (command.on === "video" && m.type === "videoMessage") {
                            if (command.fromMe == true && !m.client.isCreator) return;
                            if (command.onlyGroup == true && !m.isGroup) return;
                            if (command.onlyPm == true && m.isGroup) return;
                            command.function(m, m.client.text, m.client.command, chatUpdate);
                        } else if (command.on === "audio" && m.type === "audioMessage") {
                            if (command.fromMe == true && !m.client.isCreator) return;
                            if (command.onlyGroup == true && !m.isGroup) return;
                            if (command.onlyPm == true && m.isGroup) return;
                            command.function(m, m.client.text, m.client.command, chatUpdate);
                            }
                        }
                    });
                    // some externel function
                    try {
                        if (READ_CHAT == "true") {
                            conn.readMessages([m.key])
                        }
                        if (m.message) {
                            console.log("[ MESSAGE ]"),
                                console.log(new Date()),
                                console.log(m.client.displayText || m.type) + "\n" + console.log("=> From"),
                                console.log(m.client.pushName),
                                console.log(m.sender) + "\n" + console.log("=> In"),
                                console.log(m.isGroup ? m.client.pushName : "Private Chat", m.from)
                        }
                    } catch (err) {
                        console.log(err);
                    }
                    let isRunned = false;
                    if (isRunned == false) {
                        if (AUTO_BIO && AUTO_BIO != 'false') {
                            setInterval(async () => {
                                pstime = new Date().toLocaleDateString("EN", {
                                    weekday: "long",
                                    year: "numeric",
                                    month: "long",
                                    day: "numeric",
                                });
                                psnewt = new Date().toLocaleString("LK", {
                                    timeZone: timezons
                                }).split(" ")[1];
                                const biography = AUTO_BIO.replace('&time', psnewt).replace('&date', pstime);
                                await conn.updateProfileStatus(biography);
                            }, 1000 * 60);
                        };
                        setInterval(async () => {
                            /*
                            let currentTime = new Date().toLocaleString("LK", {
                                timeZone: TIME_ZONE,
                                hour12: false,
                            }).split(" ")[1];
                            currentTime = currentTime.split(':');
                            currentTime = currentTime[0] + ':' + currentTime[1];
                            let mute = await getAutomutes(m.client.user.number);
                            if (mute !== 'no data') {
                                mute.map(async ({
                                    jid,
                                    time
                                }) => {
                                    if (currentTime == time) {
                                        return await conn.groupSettingUpdate(jid, "announcement");
                                    }
                                })
                            }
                            let unmute = await getAutoUnMutes(m.client.user.number);
                            if (unmute == 'no data') return;
                            unmute.map(async ({
                                jid,
                                time
                            }) => {
                                if (currentTime == time) {
                                    return await conn.groupSettingUpdate(jid, "not_announcement");
                                }
                            })
                            */
                        }, 1000 * 55);
                    }
                    isRunned = true;
                    // all link ban
                    if (m.isGroup) {
                        let text = (m.client.displayText || 'ßßßßß').toLowerCase();
                        let actionLink = await getAntiLink(m);
                        let actionBadWord = await getBadWord(m);
                        let actionSpam = await getGroupSpam(m);
                        let actionWord = await GetWords(m);
                        let actionFake = await GetFake(m);
                        let adm = await isBotAdmin(m)
                                if (!adm) return;
                                let admm = await isAdmin(m)
                                if (admm) return;
                        if (actionLink.values == 'true' && !m.client.isCreator) {
                            if (text.includes('http')) {
                                if (actionLink.action == "warn") {
                                    await conn.sendMessage(m.from, {
                                        delete: {
                                            remoteJid: m.key.remoteJid,
                                            fromMe: m.fromMe,
                                            id: m.id,
                                            participant: m.sender
                                        }
                                    })
                                    const u = m.sender;
                                    const t = "The law in the group was not accepted";
                                    const d = await setWarn(u, m, t)
                                    let remains = WARNCOUND - d.count;
                                    let warnmsg = `❏─────[ ᴡᴀʀɴɪɴɢ ]─────❏
│ User :-${d.user}
❏───────────────────❏
┏─────── INFO ───────❏
│ Reason :- ${d.reason}
│ Count :- ${d.count}
│ Remaining :- ${remains}
┗•─────────────────❏`
                                    await m.reply(warnmsg)
                                    if (remains <= 0) {
                                        const d = await ResetWarn(u, m)
                                        await conn.groupParticipantsUpdate(m.from, [m.sender], "remove");
                                        return await m.reply("_Your warning has been completed and is being removed from the group_")
                                    }
                                } else if (actionLink.action == "kick") {
                                    await conn.sendMessage(m.from, {
                                        delete: {
                                            remoteJid: m.key.remoteJid,
                                            fromMe: m.fromMe,
                                            id: m.id,
                                            participant: m.sender
                                        }
                                    })
                                    await conn.groupParticipantsUpdate(m.from, [m.sender], "remove");
                                    return await m.reply("_Links Not allowed in this group_")
                                } else {
                                    await conn.sendMessage(m.from, {
                                        delete: {
                                            remoteJid: m.key.remoteJid,
                                            fromMe: m.fromMe,
                                            id: m.id,
                                            participant: m.sender
                                        }
                                    })
                                    return await m.reply("_Links Not allowed in this group_")
                                }
                            }
                        }
                        //bad word
                        if (actionBadWord.values == 'true' && !m.client.isCreator) {
                            if (badWordDetect(m.client.body.toLowerCase())) {
                                if (actionBadWord.action == "warn") {
                                    await conn.sendMessage(m.from, {
                                        delete: {
                                            remoteJid: m.key.remoteJid,
                                            fromMe: m.fromMe,
                                            id: m.id,
                                            participant: m.sender
                                        }
                                    })
                                    const u = m.sender;
                                    const t = "The law in the group was not accepted";
                                    const d = await setWarn(u, m, t)
                                    let remains = WARNCOUND - d.count;
                                    let warnmsg = `❏─────[ ᴡᴀʀɴɪɴɢ ]─────❏
│ User :-${d.user}
❏───────────────────❏
┏─────── INFO ───────❏
│ Reason :- ${d.reason}
│ Count :- ${d.count}
│ Remaining :- ${remains}
┗•─────────────────❏`
                                    await m.reply(warnmsg)
                                    if (remains <= 0) {
                                        const d = await ResetWarn(u, m)
                                        await conn.groupParticipantsUpdate(m.from, [m.sender], "remove");
                                        return await m.reply("_Your warning has been completed and is being removed from the group_")
                                    }
                                } else if (actionBadWord.action == "kick") {
                                    await conn.sendMessage(m.from, {
                                        delete: {
                                            remoteJid: m.key.remoteJid,
                                            fromMe: m.fromMe,
                                            id: m.id,
                                            participant: m.sender
                                        }
                                    })
                                    await conn.groupParticipantsUpdate(m.from, [m.sender], "remove");
                                    return await m.reply("_Bad word Detected_")
                                } else {
                                    await conn.sendMessage(m.from, {
                                        delete: {
                                            remoteJid: m.key.remoteJid,
                                            fromMe: m.fromMe,
                                            id: m.id,
                                            participant: m.sender
                                        }
                                    })
                                    return await m.reply("_This message contains profanity!, it is not allowed in this group_")
                                }
                            }
                        }
                        //spam group
                        if (actionSpam.values == 'true' && !m.client.isCreator) {
                            let iidd = m.jid + m.sender;
                            if (userGroupQuickMsgd(iidd)) {
                                if (actionSpam.action == "warn") {
                                    await conn.sendMessage(m.from, {
                                        delete: {
                                            remoteJid: m.key.remoteJid,
                                            fromMe: m.fromMe,
                                            id: m.id,
                                            participant: m.sender
                                        }
                                    })
                                    const u = m.sender;
                                    const t = "The law in the group was not accepted";
                                    const d = await setWarn(u, m, t)
                                    let remains = WARNCOUND - d.count;
                                    let warnmsg = `❏─────[ ᴡᴀʀɴɪɴɢ ]─────❏
│ User :-${d.user}
❏───────────────────❏
┏─────── INFO ───────❏
│ Reason :- ${d.reason}
│ Count :- ${d.count}
│ Remaining :- ${remains}
┗•─────────────────❏`
                                    await m.reply(warnmsg)
                                    if (remains <= 0) {
                                        const d = await ResetWarn(u, m)
                                        await conn.groupParticipantsUpdate(m.from, [m.sender], "remove");
                                        return await m.reply("_Your warning has been completed and is being removed from the group_")
                                    }
                                } else if (actionSpam.action == "kick") {
                                    await conn.sendMessage(m.from, {
                                        delete: {
                                            remoteJid: m.key.remoteJid,
                                            fromMe: m.fromMe,
                                            id: m.id,
                                            participant: m.sender
                                        }
                                    })
                                    await conn.groupParticipantsUpdate(m.from, [m.sender], "remove");
                                    return await m.reply("_Continuous messages are not allowed in this group_")
                                } else {
                                    await conn.sendMessage(m.from, {
                                        delete: {
                                            remoteJid: m.key.remoteJid,
                                            fromMe: m.fromMe,
                                            id: m.id,
                                            participant: m.sender
                                        }
                                    })
                                    return await m.reply("_Continuous messages are not allowed in this group_")
                                }
                            } else if(m.client.body.length > 250) {
                                addGroupQuickMsgd(iidd);
                            }
                        }
                        //antiword
                        if (actionWord.values && actionWord.values != 'no data') {
                            let text = m.client.displayText.toLowerCase() || 'ßßßßß';
                            if (actionWord.values.includes(',')) {
                                let value = actionWord.values.split(',')
                                await value.map(async (v) => {
                                    if (v && text.includes(v) && !m.client.isCreator) {
                                        if (actionWord.action == "warn") {
                                            await conn.sendMessage(m.from, {
                                                delete: {
                                                    remoteJid: m.key.remoteJid,
                                                    fromMe: m.fromMe,
                                                    id: m.id,
                                                    participant: m.sender
                                                }
                                            })
                                            const u = m.sender;
                                            const t = "The law in the group was not accepted";
                                            const d = await setWarn(u, m, t)
                                            let remains = WARNCOUND - d.count;
                                            let warnmsg = `❏─────[ ᴡᴀʀɴɪɴɢ ]─────❏
│ User :-${d.user}
❏───────────────────❏
┏─────── INFO ───────❏
│ Reason :- ${d.reason}
│ Count :- ${d.count}
│ Remaining :- ${remains}
┗•─────────────────❏`
                                            await m.reply(warnmsg)
                                            if (remains <= 0) {
                                                const d = await ResetWarn(u, m)
                                                await conn.groupParticipantsUpdate(m.from, [m.sender], "remove");
                                                return await m.reply("_Your warning has been completed and is being removed from the group_")
                                            };
                                        } else if (actionWord.action == "kick") {
                                            await conn.groupParticipantsUpdate(m.from, [m.sender], "remove");
                                            return await m.reply("_AntiWord detected_")
                                        } else {
                                            await conn.sendMessage(m.from, {
                                                delete: {
                                                    remoteJid: m.key.remoteJid,
                                                    fromMe: m.fromMe,
                                                    id: m.id,
                                                    participant: m.sender
                                                }
                                            })
                                            return await m.reply("_AntiWord detected_")
                                        }
                                    }
                                })
                            } else if (actionWord.values) {
                                if (text.includes(actionWord.values) && !m.client.isCreator) {
                                    if (actionWord.action == "warn") {
                                        await conn.sendMessage(m.from, {
                                            delete: {
                                                remoteJid: m.key.remoteJid,
                                                fromMe: m.fromMe,
                                                id: m.id,
                                                participant: m.sender
                                            }
                                        })
                                        const u = m.sender;
                                        const t = "The law in the group was not accepted";
                                        const d = await setWarn(u, m, t)
                                        let remains = WARNCOUND - d.count;
                                        let warnmsg = `❏─────[ ᴡᴀʀɴɪɴɢ ]─────❏
│ User :-${d.user}
❏───────────────────❏
┏─────── INFO ───────❏
│ Reason :- ${d.reason}
│ Count :- ${d.count}
│ Remaining :- ${remains}
┗•─────────────────❏`
                                        await m.reply(warnmsg)
                                        if (remains <= 0) {
                                            const d = await ResetWarn(u, m)
                                            await conn.groupParticipantsUpdate(m.from, [m.sender], "remove");
                                            return await m.reply("_Your warning has been completed and is being removed from the group_")
                                        };
                                    } else if (actionWord.action == "kick") {
                                        await conn.groupParticipantsUpdate(m.from, [m.sender], "remove");
                                        return await m.reply("_AntiWord detected_")
                                    }
                                    else {
                                        await conn.sendMessage(m.from, {
                                            delete: {
                                                remoteJid: m.key.remoteJid,
                                                fromMe: m.fromMe,
                                                id: m.id,
                                                participant: m.sender
                                            }
                                        })
                                        return await m.reply("_AntiWord detected_")
                                    }
                                }
                            }
                        }
                        if (actionFake && actionFake !== 'no data') {
                            let sender = m.sender || 'ßßß';
                            if (actionFake.includes(',')) {
                                let value = actionFake.split(',')
                                await value.map(async (v) => {
                                    if (v && sender.startsWith(v) && !m.client.isCreator) {
                                        await conn.sendMessage(m.from, {
                                            delete: {
                                                remoteJid: m.key.remoteJid,
                                                fromMe: m.fromMe,
                                                id: m.id,
                                                participant: m.sender
                                            }
                                        })
                                        await m.reply("this group isn't allowed your number format")
                                        await conn.groupParticipantsUpdate(m.from, [m.sender], "remove");
                                    }
                                })
                            } else if (actionFake) {
                                if (sender.startsWith(actionFake) && !m.client.isCreator) {
                                    await conn.sendMessage(m.from, {
                                        delete: {
                                            remoteJid: m.key.remoteJid,
                                            fromMe: m.fromMe,
                                            id: m.id,
                                            participant: m.sender
                                        }
                                    })
                                    await m.reply("this group isn't allowed your number format")
                                    await conn.groupParticipantsUpdate(m.from, [m.sender], "remove");
                                }
                            }
                        }
                    }
                    //end
                    //automatic reaction
                    if(!em_ed){
                    if (REACT == 'true' && m && !isReact) {
                        if (m.client.body.match(/\p{EPres}|\p{ExtPict}/gu)) {
                            await sleep(100)
                            await conn.sendMessage(m.from, {
                                react: {
                                    text: m.client.body.match(/\p{EPres}|\p{ExtPict}/gu)[0],
                                    key: m.key
                                }
                            });
                        } else {
                            let reactArray = ['💘','💝','💖','💗','💓','💞','💕','💟','❣️','💔','❤️','🧡','💛','💚','💙','💜','🤎','🖤','🤍','❤️‍','🔥','❤️‍','🩹','💯','♨️','💢','💬','👁️‍🗨️','🗨️','🗯️','💭','💤','🌐','♠️','♥️','♦️','♣️','🃏','🀄️','🎴','🎭️','🔇','🔈️','🔉','🔊','🔔','🔕','🎼','🎵','🎶','💹','🏧','🚮','🚰','♿️','🚹️','🚺️','🚻','🚼️','🚾','🛂','🛃','🛄','🛅','⚠️','🚸','⛔️','🚫','🚳','🚭️','🚯','🚱','🚷','📵','🔞','☢️','☣️','⬆️','↗️','➡️','↘️','⬇️','↙️','⬅️','↖️','↕️','↔️','↩️','↪️','⤴️','⤵️','🔃','🔄','🔙','🔚','🔛','🔜','🔝','🛐','⚛️','🕉️','✡️','☸️','☯️','✝️','☦️','☪️','☮️','🕎','🔯','♈️','♉️','♊️','♋️','♌️','♍️','♎️','♏️','♐️','♑️','♒️','♓️','⛎','🔀','🔁','🔂','▶️','⏩️','⏭️','⏯️','◀️','⏪️','⏮️','🔼','⏫','🔽','⏬','⏸️','⏹️','⏺️','⏏️','🎦','🔅','🔆','📶','📳','📴','♀️','♂️','⚧','✖️','➕','➖','➗','♾️','‼️','⁉️','❓️','❔','❕','❗️','〰️','💱','💲','⚕️','♻️','⚜️','🔱','📛','🔰','⭕️','✅','☑️','✔️','❌','❎','➰','➿','〽️','✳️','✴️','❇️','©️','®️','™️','#️⃣','*️⃣','0️⃣','1️⃣','2️⃣','3️⃣','4️⃣','5️⃣','6️⃣','7️⃣','8️⃣','9️⃣','🔟','🔠','🔡','🔢','🔣','🔤','🅰️','🆎','🅱️','🆑','🆒','🆓','ℹ️','🆔','Ⓜ️','🆕','🆖','🅾️','🆗','🅿️','🆘','🆙','🆚','🈁','🈂️','🈷️','🈶','🈯️','🉐','🈹','🈚️','🈲','🉑','🈸','🈴','🈳','㊗️','㊙️','🈺','🈵','🔴','🟠','🟡','🟢','🔵','🟣','🟤','⚫️','⚪️','🟥','🟧','🟨','🟩','🟦','🟪','🟫','⬛️','⬜️','◼️','◻️','◾️','◽️','▪️','▫️','🔶','🔷','🔸','🔹','🔺','🔻','💠','🔘','🔳','🔲','🕛️','🕧️','🕐️','🕜️','🕑️','🕝️','🕒️','🕞️','🕓️','🕟️','🕔️','🕠️','🕕️','🕡️','🕖️','🕢️','🕗️','🕣️','🕘️','🕤️','🕙️','🕥️','🕚️','🕦️','*️','#️','0️','1️','2️','3️','4️','5️','6️','7️','8️','9️','🛎️','🧳','⌛️','⏳️','⌚️','⏰','⏱️','⏲️','🕰️','🌡️','🗺️','🧭','🎃','🎄','🧨','🎈','🎉','🎊','🎎','🎏','🎐','🎀','🎁','🎗️','🎟️','🎫','🔮','🧿','🎮️','🕹️','🎰','🎲','♟️','🧩','🧸','🖼️','🎨','🧵','🧶','👓️','🕶️','🥽','🥼','🦺','👔','👕','👖','🧣','🧤','🧥','🧦','👗','👘','🥻','🩱','🩲','🩳','👙','👚','👛','👜','👝','🛍️','🎒','👞','👟','🥾','🥿','👠','👡','🩰','👢','👑','👒','🎩','🎓️','🧢','⛑️','📿','💄','💍','💎','📢','📣','📯','🎙️','🎚️','🎛️','🎤','🎧️','📻️','🎷','🎸','🎹','🎺','🎻','🪕','🥁','📱','📲','☎️','📞','📟️','📠','🔋','🔌','💻️','🖥️','🖨️','⌨️','🖱️','🖲️','💽','💾','💿️','📀','🧮','🎥','🎞️','📽️','🎬️','📺️','📷️','📸','📹️','📼','🔍️','🔎','🕯️','💡','🔦','🏮','🪔','📔','📕','📖','📗','📘','📙','📚️','📓','📒','📃','📜','📄','📰','🗞️','📑','🔖','🏷️','💰️','💴','💵','💶','💷','💸','💳️','🧾','✉️','💌','📧','🧧','📨','📩','📤️','📥️','📦️','📫️','📪️','📬️','📭️','📮','🗳️','✏️','✒️','🖋️','🖊️','🖌️','🖍️','📝','💼','📁','📂','🗂️','📅','📆','🗒️','🗓️','📇','📈','📉','📊','📋️','📌','📍','📎','🖇️','📏','📐','✂️','🗃️','🗄️','🗑️','🔒️','🔓️','🔏','🔐','🔑','🗝️','🔨','🪓','⛏️','⚒️','🛠️','🗡️','⚔️','💣️','🏹','🛡️','🔧','🔩','⚙️','🗜️','⚖️','🦯','🔗','⛓️','🧰','🧲','⚗️','🧪','🧫','🧬','🔬','🔭','📡','💉','🩸','💊','🩹','🩺','🚪','🛏️','🛋️','🪑','🚽','🚿','🛁','🪒','🧴','🧷','🧹','🧺','🧻','🧼','🧽','🧯','🛒','🚬','⚰️','⚱️','🏺','🕳️','🏔️','⛰️','🌋','🗻','🏕️','🏖️','🏜️','🏝️','🏟️','🏛️','🏗️','🧱','🏘️','🏚️','🏠️','🏡','🏢','🏣','🏤','🏥','🏦','🏨','🏩','🏪','🏫','🏬','🏭️','🏯','🏰','💒','🗼','🗽','⛪️','🕌','🛕','🕍','⛩️','🕋','⛲️','⛺️','🌁','🌃','🏙️','🌄','🌅','🌆','🌇','🌉','🗾','🏞️','🎠','🎡','🎢','💈','🎪','🚂','🚃','🚄','🚅','🚆','🚇️','🚈','🚉','🚊','🚝','🚞','🚋','🚌','🚍️','🚎','🚐','🚑️','🚒','🚓','🚔️','🚕','🚖','🚗','🚘️','🚙','🚚','🚛','🚜','🏎️','🏍️','🛵','🦽','🦼','🛺','🚲️','🛴','🛹','🚏','🛣️','🛤️','🛢️','⛽️','🚨','🚥','🚦','🛑','🚧','⚓️','⛵️','🛶','🚤','🛳️','⛴️','🛥️','🚢','✈️','🛩️','🛫','🛬','🪂','💺','🚁','🚟','🚠','🚡','🛰️','🚀','🛸','🎆','🎇','🎑','🗿','⚽️','⚾️','🥎','🏀','🏐','🏈','🏉','🎾','🥏','🎳','🏏','🏑','🏒','🥍','🏓','🏸','🥊','🥋','🥅','⛳️','⛸️','🎣','🤿','🎽','🎿','🛷','🥌','🎯','🪀','🪁','🎱','🎖️','🏆️','🏅','🥇','🥈','🥉','🍇','🍈','🍉','🍊','🍋','🍌','🍍','🥭','🍎','🍏','🍐','🍑','🍒','🍓','🥝','🍅','🥥','🥑','🍆','🥔','🥕','🌽','🌶️','🥒','🥬','🥦','🧄','🧅','🍄','🥜','🌰','🍞','🥐','🥖','🥨','🥯','🥞','🧇','🧀','🍖','🍗','🥩','🥓','🍔','🍟','🍕','🌭','🥪','🌮','🌯','🥙','🧆','🥚','🍳','🥘','🍲','🥣','🥗','🍿','🧈','🧂','🥫','🍱','🍘','🍙','🍚','🍛','🍜','🍝','🍠','🍢','🍣','🍤','🍥','🥮','🍡','🥟','🥠','🥡','🍦','🍧','🍨','🍩','🍪','🎂','🍰','🧁','🥧','🍫','🍬','🍭','🍮','🍯','🍼','🥛','☕️','🍵','🍶','🍾','🍷','🍸️','🍹','🍺','🍻','🥂','🥃','🥤','🧃','🧉','🧊','🥢','🍽️','🍴','🥄','🔪','🐵','🐒','🦍','🦧','🐶','🐕️','🦮','🐕‍','🦺','🐩','🐺','🦊','🦝','🐱','🐈️','🐈‍','🦁','🐯','🐅','🐆','🐴','🐎','🦄','🦓','🦌','🐮','🐂','🐃','🐄','🐷','🐖','🐗','🐽','🐏','🐑','🐐','🐪','🐫','🦙','🦒','🐘','🦏','🦛','🐭','🐁','🐀','🐹','🐰','🐇','🐿️','🦔','🦇','🐻','🐻‍','❄️','🐨','🐼','🦥','🦦','🦨','🦘','🦡','🐾','🦃','🐔','🐓','🐣','🐤','🐥','🐦️','🐧','🕊️','🦅','🦆','🦢','🦉','🦩','🦚','🦜','🐸','🐊','🐢','🦎','🐍','🐲','🐉','🦕','🦖','🐳','🐋','🐬','🐟️','🐠','🐡','🦈','🐙','🦑','🦀','🦞','🦐','🦪','🐚','🐌','🦋','🐛','🐜','🐝','🐞','🦗','🕷️','🕸️','🦂','🦟','🦠','💐','🌸','💮','🏵️','🌹','🥀','🌺','🌻','🌼','🌷','🌱','🌲','🌳','🌴','🌵','🎋','🎍','🌾','🌿','☘️','🍀','🍁','🍂','🍃','🌍️','🌎️','🌏️','🌑','🌒','🌓','🌔','🌕️','🌖','🌗','🌘','🌙','🌚','🌛','🌜️','☀️','🌝','🌞','🪐','💫','⭐️','🌟','✨','🌠','🌌','☁️','⛅️','⛈️','🌤️','🌥️','🌦️','🌧️','🌨️','🌩️','🌪️','🌫️','🌬️','🌀','🌈','🌂','☂️','☔️','⛱️','⚡️','❄️','☃️','⛄️','☄️','🔥','💧','🌊','💥','💦','💨','😀','😃','😄','😁','😆','😅','🤣','😂','🙂','🙃','😉','😊','😇','🥰','😍','🤩','😘','😗','☺️','😚','😙','😋','😛','😜','🤪','😝','🤑','🤗','🤭','🤫','🤔','🤐','🤨','😐️','😑','😶','😏','😒','🙄','😬','🤥','😌','😔','😪','😮‍','💨','🤤','😴','😷','🤒','🤕','🤢','🤮','🤧','🥵','🥶','😶‍','🌫️','🥴','😵‍','💫','😵','🤯','🤠','🥳','😎','🤓','🧐','😕','😟','🙁','☹️','😮','😯','😲','😳','🥺','😦','😧','😨','😰','😥','😢','😭','😱','😖','😣','😞','😓','😩','😫','🥱','😤','😡','😠','🤬','😈','👿','💀','☠️','💩','🤡','👹','👺','👻','👽️','👾','🤖','😺','😸','😹','😻','😼','😽','🙀','😿','😾','🙈','🙉','🙊','👋','🤚','🖐️','✋','🖖','👌','🤏','✌️','🤞','🤟','🤘','🤙','👈️','👉️','👆️','🖕','👇️','☝️','👍️','👎️','✊','👊','🤛','🤜','👏','🙌','👐','🤲','🤝','🙏','✍️','💅','🤳','💪','🦾','🦿','🦵','🦶','👂️','🦻','👃','🧠','🦷','🦴','👀','👁️','👅','👄','💋','👶','🧒','👦','👧','🧑','👨','👩','🧔','🧔‍♀️','🧔‍♂️','🧑','👨‍','🦰','👩‍','🦰','🧑','👨‍','🦱','👩‍','🦱','🧑','👨‍','🦳','👩‍','🦳','🧑','👨‍','🦲','👩‍','🦲','👱','👱‍♂️','👱‍♀️','🧓','👴','👵','🙍','🙍‍♂️','🙍‍♀️','🙎','🙎‍♂️','🙎‍♀️','🙅','🙅‍♂️','🙅‍♀️','🙆','🙆‍♂️','🙆‍♀️','💁','💁‍♂️','💁‍♀️','🙋','🙋‍♂️','🙋‍♀️','🧏','🧏‍♂️','🧏‍♀️','🙇','🙇‍♂️','🙇‍♀️','🤦','🤦‍♂️','🤦‍♀️','🤷','🤷‍♂️','🤷‍♀️','🧑‍⚕️','👨‍⚕️','👩‍⚕️','🧑‍🎓','👨‍🎓','👩‍🎓','🧑‍🏫','👨‍🏫','👩‍🏫','🧑‍⚖️','👨‍⚖️','👩‍⚖️','🧑‍🌾','👨‍🌾','👩‍🌾','🧑‍🍳','👨‍🍳','👩‍🍳','🧑‍🔧','👨‍🔧','👩‍🔧','🧑‍🏭','👨‍🏭','👩‍🏭','🧑‍💼','👨‍💼','👩‍💼','🧑‍🔬','👨‍🔬','👩‍🔬','🧑‍💻','👨‍💻','👩‍💻','🧑‍🎤','👨‍🎤','👩‍🎤','🧑‍🎨','👨‍🎨','👩‍🎨','🧑‍✈️','👨‍✈️','👩‍✈️','🧑‍🚀','👨‍🚀','👩‍🚀','🧑‍🚒','👨‍🚒','👩‍🚒','👮','👮‍♂️','👮‍♀️','🕵️','🕵️‍♂️','🕵️‍♀️','💂','💂‍♂️','💂‍♀️','👷','👷‍♂️','👷‍♀️','🤴','👸','👳','👳‍♂️','👳‍♀️','👲','🧕','🤵','🤵‍♂️','🤵‍♀️','👰','👰‍♂️','👰‍♀️','🤰','🤱','👩‍','🍼','👨‍','🍼','🧑‍','🍼','👼','🎅','🤶','🧑‍','🎄','🦸','🦸‍♂️','🦸‍♀️','🦹','🦹‍♂️','🦹‍♀️','🧙','🧙‍♂️','🧙‍♀️','🧚','🧚‍♂️','🧚‍♀️','🧛','🧛‍♂️','🧛‍♀️','🧜','🧜‍♂️','🧜‍♀️','🧝','🧝‍♂️','🧝‍♀️','🧞','🧞‍♂️','🧞‍♀️','🧟','🧟‍♂️','🧟‍♀️','💆','💆‍♂️','💆‍♀️','💇','💇‍♂️','💇‍♀️','🚶','🚶‍♂️','🚶‍♀️','🧍','🧍‍♂️','🧍‍♀️','🧎','🧎‍♂️','🧎‍♀️','🧑‍','🦯','👨‍','🦯','👩‍','🦯','🧑‍','🦼','👨‍','🦼','👩‍','🦼','🧑‍','🦽','👨‍','🦽','👩‍','🦽','🏃','🏃‍♂️','🏃‍♀️','💃','🕺','🕴️','👯','👯‍♂️','👯‍♀️','🧖','🧖‍♂️','🧖‍♀️','🧗','🧗‍♂️','🧗‍♀️','🤺','🏇','⛷️','🏂️','🏌️','🏌️‍♂️','🏌️‍♀️','🏄️','🏄‍♂️','🏄‍♀️','🚣','🚣‍♂️','🚣‍♀️','🏊️','🏊‍♂️','🏊‍♀️','⛹️','⛹️‍♂️','⛹️‍♀️','🏋️','🏋️‍♂️','🏋️‍♀️','🚴','🚴‍♂️','🚴‍♀️','🚵','🚵‍♂️','🚵‍♀️','🤸','🤸‍♂️','🤸‍♀️','🤼','🤼‍♂️','🤼‍♀️','🤽','🤽‍♂️','🤽‍♀️','🤾','🤾‍♂️','🤾‍♀️','🤹','🤹‍♂️','🤹‍♀️','🧘','🧘‍♂️','🧘‍♀️','🛀','🛌','🧑‍','🤝‍','🧑','👭','👫','👬','💏','👩‍❤️‍💋‍👨','👨‍❤️‍💋‍👨','👩‍❤️‍💋‍👩','💑','👩‍❤️‍👨','👨‍❤️‍👨','👩‍❤️‍👩','👪️','👨‍👩‍👦','👨‍👩‍👧','👨‍👩‍👧‍👦','👨‍👩‍👦‍👦','👨‍👩‍👧‍👧','👨‍👨‍👦','👨‍👨‍👧','👨‍👨‍👧‍👦','👨‍👨‍👦‍👦','👨‍👨‍👧‍👧','👩‍👩‍👦','👩‍👩‍👧','👩‍👩‍👧‍👦','👩‍👩‍👦‍👦','👩‍👩‍👧‍👧','👨‍👦','👨‍👦‍👦','👨‍👧','👨‍👧‍👦','👨‍👧‍👧','👩‍👦','👩‍👦‍👦','👩‍👧','👩‍👧‍👦','👩‍👧‍👧','🗣️','👤','👥','👣'];
                            let getType = reactArray[Math.floor(Math.random() * reactArray.length)];
                            await sleep(100)
                            await conn.sendMessage(m.from, {
                                react: {
                                    text: getType,
                                    key: m.key
                                }
                            });
                        }
                    } else if (REACT != 'true' && m && REACT_EMOJI == "true" && !isReact) {
                        if (m.client.body.match(/\p{EPres}|\p{ExtPict}/gu)) {
                            await conn.sendMessage(m.from, {
                                    react: {
                                        text: m.client.body.match(/\p{EPres}|\p{ExtPict}/gu)[0],
                                        key: m.key
                                    }
                                });
                            }
                        }
                    }
                });
            } else if (connection === "close") {
                console.log("Connection closed with bot. Please put New Session ID again.");
                await sleep(3000)
                WhatsBotConnect();
            }
        });
        setInterval(async () => {
            await removeFile("");
            await removeFile("media");
        }, 1000 * 30);
    } catch (err) {
        console.log(err)
    }
} // function closing
app.get("/", (req, res) => {
    res.send("Hello Inrl started\nversion: "+require("./package.json").version);
});
app.listen(port, () => console.log(`Inrl Server listening on port http://localhost:${port}`));
setTimeout(() => {
    WhatsBotConnect();
}, 3000);
